$date
	Thu Jul 24 09:57:31 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module complex_arm_tb $end
$var wire 32 ! mem_rdata [31:0] $end
$var wire 1 " mem_ready $end
$var wire 1 # running $end
$var wire 1 $ mem_we $end
$var wire 32 % mem_wdata [31:0] $end
$var wire 1 & mem_re $end
$var wire 4 ' mem_be [3:0] $end
$var wire 32 ( mem_addr [31:0] $end
$var wire 32 ) debug_pc [31:0] $end
$var wire 32 * debug_instr [31:0] $end
$var reg 1 + clk $end
$var reg 1 , debug_en $end
$var reg 1 - fiq $end
$var reg 1 . halt $end
$var reg 1 / irq $end
$var reg 1 0 rst_n $end
$scope function get_alu_name $end
$var reg 4 1 op [3:0] $end
$upscope $end
$scope function get_instr_type_name $end
$var reg 4 2 itype [3:0] $end
$upscope $end
$scope function get_shift_name $end
$var reg 2 3 stype [1:0] $end
$upscope $end
$scope module dut $end
$var wire 1 + clk $end
$var wire 32 4 data_mem_addr [31:0] $end
$var wire 1 5 data_mem_re $end
$var wire 32 6 data_mem_wdata [31:0] $end
$var wire 1 7 data_mem_we $end
$var wire 1 , debug_en $end
$var wire 32 8 debug_instr [31:0] $end
$var wire 32 9 debug_pc [31:0] $end
$var wire 1 - fiq $end
$var wire 1 . halt $end
$var wire 1 / irq $end
$var wire 32 : load_data [31:0] $end
$var wire 1 ; mem_operation_active $end
$var wire 32 < mem_rdata [31:0] $end
$var wire 1 " mem_ready $end
$var wire 32 = mem_wdata [31:0] $end
$var wire 1 > mul_accumulate $end
$var wire 1 ? mul_en $end
$var wire 1 @ mul_signed $end
$var wire 32 A reg_pc_out [31:0] $end
$var wire 1 0 rst_n $end
$var wire 1 B write_lr $end
$var wire 1 C thumb_mode $end
$var wire 1 D shifter_carry_out $end
$var wire 32 E shifted_operand [31:0] $end
$var wire 32 F reg_spsr_out [31:0] $end
$var wire 32 G reg_rn_data [31:0] $end
$var wire 32 H reg_rm_data [31:0] $end
$var wire 32 I reg_cpsr_out [31:0] $end
$var wire 1 J mul_zero $end
$var wire 1 K mul_result_ready $end
$var wire 32 L mul_result_lo [31:0] $end
$var wire 32 M mul_result_hi [31:0] $end
$var wire 1 N mul_negative $end
$var wire 1 O mul_long $end
$var wire 1 $ mem_we $end
$var wire 1 & mem_re $end
$var wire 4 P mem_be [3:0] $end
$var wire 32 Q mem_address [31:0] $end
$var wire 32 R mem_addr [31:0] $end
$var wire 32 S lr_data [31:0] $end
$var wire 32 T fetch_pc [31:0] $end
$var wire 1 U fetch_mem_re $end
$var wire 32 V fetch_mem_addr [31:0] $end
$var wire 32 W fetch_instruction [31:0] $end
$var wire 1 X fetch_instr_valid $end
$var wire 1 Y decode_valid $end
$var wire 2 Z decode_shift_type [1:0] $end
$var wire 5 [ decode_shift_amount [4:0] $end
$var wire 1 \ decode_set_flags $end
$var wire 4 ] decode_rn [3:0] $end
$var wire 4 ^ decode_rm [3:0] $end
$var wire 4 _ decode_rd [3:0] $end
$var wire 32 ` decode_pc [31:0] $end
$var wire 1 a decode_mem_writeback $end
$var wire 1 b decode_mem_up $end
$var wire 1 c decode_mem_pre $end
$var wire 1 d decode_mem_load $end
$var wire 1 e decode_mem_byte $end
$var wire 1 f decode_is_memory $end
$var wire 1 g decode_is_branch $end
$var wire 4 h decode_instr_type [3:0] $end
$var wire 12 i decode_immediate [11:0] $end
$var wire 1 j decode_imm_en $end
$var wire 4 k decode_condition [3:0] $end
$var wire 24 l decode_branch_offset [23:0] $end
$var wire 1 m decode_branch_link $end
$var wire 4 n decode_alu_op [3:0] $end
$var wire 4 o data_mem_be [3:0] $end
$var wire 5 p current_mode [4:0] $end
$var wire 1 q condition_passed $end
$var wire 1 r alu_zero $end
$var wire 32 s alu_result [31:0] $end
$var wire 1 t alu_overflow $end
$var wire 1 u alu_negative $end
$var wire 1 v alu_carry_out $end
$var wire 4 w actual_rd_addr [3:0] $end
$var reg 1 x alu_carry_in $end
$var reg 32 y alu_operand_a [31:0] $end
$var reg 32 z alu_operand_b [31:0] $end
$var reg 1 { branch_taken $end
$var reg 32 | branch_target [31:0] $end
$var reg 3 } current_state [2:0] $end
$var reg 1 ~ fetch_en $end
$var reg 1 !" flush $end
$var reg 8 "" imm_value [7:0] $end
$var reg 1 #" mode_change $end
$var reg 3 $" next_state [2:0] $end
$var reg 32 %" reg_cpsr_in [31:0] $end
$var reg 1 &" reg_cpsr_we $end
$var reg 32 '" reg_pc_in [31:0] $end
$var reg 1 (" reg_pc_we $end
$var reg 32 )" reg_rd_data [31:0] $end
$var reg 1 *" reg_rd_we $end
$var reg 32 +" reg_spsr_in [31:0] $end
$var reg 1 ," reg_spsr_we $end
$var reg 5 -" rot_amount [4:0] $end
$var reg 4 ." rotate_imm [3:0] $end
$var reg 1 # running $end
$var reg 1 /" save_lr $end
$var reg 1 0" stall $end
$var reg 5 1" target_mode [4:0] $end
$scope function evaluate_condition $end
$var reg 1 2" c $end
$var reg 4 3" cond [3:0] $end
$var reg 1 4" n $end
$var reg 1 5" v $end
$var reg 1 6" z $end
$upscope $end
$scope module u_alu $end
$var wire 1 x carry_in $end
$var wire 1 v carry_out $end
$var wire 1 + clk $end
$var wire 32 7" operand_a [31:0] $end
$var wire 32 8" operand_b [31:0] $end
$var wire 1 t overflow $end
$var wire 32 9" result [31:0] $end
$var wire 1 0 rst_n $end
$var wire 1 r zero $end
$var wire 1 \ set_flags $end
$var wire 1 u negative $end
$var wire 4 :" alu_op [3:0] $end
$var reg 1 ;" alu_carry $end
$var reg 1 <" alu_overflow $end
$var reg 32 =" alu_result [31:0] $end
$var reg 33 >" extended_result [32:0] $end
$upscope $end
$scope module u_decode $end
$var wire 1 m branch_link $end
$var wire 24 ?" branch_offset [23:0] $end
$var wire 1 + clk $end
$var wire 4 @" condition [3:0] $end
$var wire 1 !" flush $end
$var wire 1 j imm_en $end
$var wire 12 A" immediate [11:0] $end
$var wire 1 f is_memory $end
$var wire 1 e mem_byte $end
$var wire 1 d mem_load $end
$var wire 1 c mem_pre $end
$var wire 1 b mem_up $end
$var wire 1 a mem_writeback $end
$var wire 4 B" rd [3:0] $end
$var wire 4 C" rm [3:0] $end
$var wire 4 D" rn [3:0] $end
$var wire 1 0 rst_n $end
$var wire 1 \ set_flags $end
$var wire 5 E" shift_amount [4:0] $end
$var wire 2 F" shift_type [1:0] $end
$var wire 1 0" stall $end
$var wire 1 C thumb_mode $end
$var wire 1 G" w_bit $end
$var wire 1 H" u_bit $end
$var wire 2 I" shift_type_field [1:0] $end
$var wire 5 J" shift_amt_field [4:0] $end
$var wire 1 K" s_bit $end
$var wire 4 L" rn_field [3:0] $end
$var wire 4 M" rm_field [3:0] $end
$var wire 4 N" rd_field [3:0] $end
$var wire 32 O" pc_out [31:0] $end
$var wire 32 P" pc_in [31:0] $end
$var wire 1 Q" p_bit $end
$var wire 6 R" op_code [5:0] $end
$var wire 2 S" op_class [1:0] $end
$var wire 1 T" l_bit_mem $end
$var wire 1 U" l_bit $end
$var wire 1 g is_branch $end
$var wire 32 V" instruction [31:0] $end
$var wire 1 X instr_valid $end
$var wire 12 W" imm_field [11:0] $end
$var wire 1 X" i_bit $end
$var wire 1 Y decode_valid $end
$var wire 4 Y" cond_field [3:0] $end
$var wire 24 Z" branch_offset_field [23:0] $end
$var wire 1 [" b_bit $end
$var wire 4 \" alu_op [3:0] $end
$var reg 4 ]" instr_type [3:0] $end
$var reg 32 ^" pc_reg [31:0] $end
$var reg 1 Y valid_reg $end
$upscope $end
$scope module u_fetch $end
$var wire 1 { branch_taken $end
$var wire 32 _" branch_target [31:0] $end
$var wire 1 + clk $end
$var wire 1 ~ fetch_en $end
$var wire 1 !" flush $end
$var wire 1 X instr_valid $end
$var wire 32 `" instruction [31:0] $end
$var wire 32 a" mem_rdata [31:0] $end
$var wire 1 " mem_ready $end
$var wire 32 b" pc_out [31:0] $end
$var wire 1 0 rst_n $end
$var wire 1 0" stall $end
$var wire 1 C thumb_mode $end
$var reg 2 c" current_state [1:0] $end
$var reg 32 d" instr_buffer [31:0] $end
$var reg 1 e" instr_ready $end
$var reg 32 f" mem_addr [31:0] $end
$var reg 1 U mem_re $end
$var reg 2 g" next_state [1:0] $end
$var reg 32 h" pc [31:0] $end
$upscope $end
$scope module u_multiply $end
$var wire 32 i" acc_hi [31:0] $end
$var wire 32 j" acc_lo [31:0] $end
$var wire 1 + clk $end
$var wire 1 > mul_accumulate $end
$var wire 1 ? mul_en $end
$var wire 1 O mul_long $end
$var wire 1 @ mul_signed $end
$var wire 1 K result_ready $end
$var wire 1 0 rst_n $end
$var wire 1 J zero $end
$var wire 32 k" result_lo [31:0] $end
$var wire 32 l" result_hi [31:0] $end
$var wire 32 m" operand_b [31:0] $end
$var wire 32 n" operand_a [31:0] $end
$var wire 1 N negative $end
$var reg 64 o" final_result [63:0] $end
$var reg 64 p" mul_result [63:0] $end
$upscope $end
$scope module u_regfile $end
$var wire 1 + clk $end
$var wire 32 q" cpsr_in [31:0] $end
$var wire 32 r" cpsr_out [31:0] $end
$var wire 1 &" cpsr_we $end
$var wire 5 s" current_mode [4:0] $end
$var wire 1 #" mode_change $end
$var wire 32 t" pc_in [31:0] $end
$var wire 32 u" pc_out [31:0] $end
$var wire 1 (" pc_we $end
$var wire 4 v" rd_addr [3:0] $end
$var wire 32 w" rd_data [31:0] $end
$var wire 1 *" rd_we $end
$var wire 4 x" rm_addr [3:0] $end
$var wire 4 y" rn_addr [3:0] $end
$var wire 1 0 rst_n $end
$var wire 32 z" spsr_in [31:0] $end
$var wire 32 {" spsr_out [31:0] $end
$var wire 1 ," spsr_we $end
$var wire 5 |" target_mode [4:0] $end
$var wire 32 }" rn_data [31:0] $end
$var wire 32 ~" rm_data [31:0] $end
$var reg 32 !# cpsr [31:0] $end
$var reg 32 "# current_spsr [31:0] $end
$var reg 32 ## rm_data_internal [31:0] $end
$var reg 32 $# rn_data_internal [31:0] $end
$var reg 32 %# spsr_abt [31:0] $end
$var reg 32 &# spsr_fiq [31:0] $end
$var reg 32 '# spsr_irq [31:0] $end
$var reg 32 (# spsr_svc [31:0] $end
$var reg 32 )# spsr_und [31:0] $end
$scope begin $ivl_for_loop0 $end
$var integer 32 *# i [31:0] $end
$upscope $end
$scope begin $ivl_for_loop1 $end
$var integer 32 +# i [31:0] $end
$upscope $end
$scope begin $ivl_for_loop2 $end
$var integer 32 ,# i [31:0] $end
$upscope $end
$upscope $end
$scope module u_shifter $end
$var wire 1 -# carry_in $end
$var wire 32 .# data_in [31:0] $end
$var wire 5 /# shift_amount [4:0] $end
$var wire 2 0# shift_type [1:0] $end
$var reg 1 D carry_out $end
$var reg 32 1# data_out [31:0] $end
$upscope $end
$upscope $end
$scope begin $ivl_for_loop3 $end
$var integer 32 2# i [31:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b100000000000 2#
b0 1#
b0 0#
b0 /#
b0 .#
0-#
b1111 ,#
b1111 +#
b10000 *#
b0 )#
b0 (#
b0 '#
b0 &#
b0 %#
b0 $#
b0 ##
b0 "#
b10011 !#
b0 ~"
b0 }"
b10011 |"
b0 {"
b0 z"
b0 y"
b0 x"
b0 w"
b0 v"
b0 u"
b0 t"
b10011 s"
b10011 r"
b10011 q"
b0 p"
b0 o"
b0 n"
b0 m"
b0 l"
b0 k"
b0 j"
b0 i"
b0 h"
b1 g"
b0 f"
0e"
b0 d"
b0 c"
b0 b"
b11100011101000000001000000000101 a"
b0 `"
b0 _"
b0 ^"
b0 ]"
b0 \"
0["
b0 Z"
b0 Y"
0X"
b0 W"
b0 V"
0U"
0T"
b0 S"
b0 R"
0Q"
b0 P"
b0 O"
b0 N"
b0 M"
b0 L"
0K"
b0 J"
b0 I"
0H"
0G"
b0 F"
b0 E"
b0 D"
b0 C"
b0 B"
b0 A"
b0 @"
b0 ?"
b0 >"
b0 ="
0<"
0;"
b0 :"
b0 9"
b0 8"
b0 7"
06"
05"
04"
b0 3"
02"
b10011 1"
00"
0/"
bx ."
bx -"
0,"
b0 +"
0*"
b0 )"
1("
b0 '"
0&"
b10011 %"
b0 $"
0#"
bx ""
0!"
1~
b0 }
b0 |
0{
b0 z
b0 y
0x
b0 w
0v
0u
0t
b0 s
1r
0q
b10011 p
b1111 o
b0 n
0m
b0 l
b0 k
0j
b0 i
b0 h
0g
0f
0e
0d
0c
0b
0a
b0 `
b0 _
b0 ^
b0 ]
0\
b0 [
b0 Z
0Y
0X
b0 W
b0 V
1U
b0 T
b100 S
b0 R
b0 Q
b1111 P
0O
0N
b0 M
b0 L
0K
1J
b10011 I
b0 H
b0 G
b0 F
b0 E
0D
0C
0B
b0 A
0@
0?
0>
b0 =
b11100011101000000001000000000101 <
0;
b11100011101000000001000000000101 :
b0 9
b0 8
07
b0 6
05
b0 4
bx 3
bx 2
bx 1
00
0/
0.
0-
1,
0+
b0 *
b0 )
b0 (
b1111 '
1&
b0 %
0$
0#
1"
b11100011101000000001000000000101 !
$end
#5
b1111 ,#
b1111 +#
b10000 *#
1+
#10
0+
#15
b1111 ,#
b1111 +#
b10000 *#
1+
#20
0+
#25
b1111 ,#
b1111 +#
b10000 *#
1+
#30
0+
#35
b1111 ,#
b1111 +#
b10000 *#
1+
#40
0+
#45
b11100011101000000010000000000011 :
b11100011101000000010000000000011 !
b11100011101000000010000000000011 <
b11100011101000000010000000000011 a"
b100 (
b100 R
b10 g"
b100 V
b100 f"
b0 h
b0 ]"
1~
b100 '"
b100 t"
1#
b1 c"
b100 T
b100 P"
b100 b"
b100 h"
10
1+
#50
0+
#55
