$date
	Thu Jul 24 15:40:19 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module thumb_bl_test_tb $end
$var wire 1 ! running $end
$var wire 1 " mem_we $end
$var wire 32 # mem_wdata [31:0] $end
$var wire 1 $ mem_re $end
$var wire 4 % mem_be [3:0] $end
$var wire 32 & mem_addr [31:0] $end
$var wire 32 ' debug_pc [31:0] $end
$var wire 32 ( debug_instr [31:0] $end
$var reg 1 ) clk $end
$var reg 1 * debug_en $end
$var reg 1 + fiq $end
$var reg 1 , halt $end
$var reg 1 - irq $end
$var reg 32 . mem_rdata [31:0] $end
$var reg 1 / mem_ready $end
$var reg 1 0 rst_n $end
$scope module u_cpu $end
$var wire 32 1 block_base_address [31:0] $end
$var wire 4 2 block_base_register [3:0] $end
$var wire 1 3 block_en $end
$var wire 1 4 block_load $end
$var wire 1 5 block_pre $end
$var wire 32 6 block_reg_rdata [31:0] $end
$var wire 1 7 block_up $end
$var wire 1 8 block_user_mode $end
$var wire 1 9 block_writeback $end
$var wire 1 ) clk $end
$var wire 32 : data_mem_addr [31:0] $end
$var wire 1 * debug_en $end
$var wire 32 ; debug_instr [31:0] $end
$var wire 32 < debug_pc [31:0] $end
$var wire 1 + fiq $end
$var wire 1 , halt $end
$var wire 1 - irq $end
$var wire 1 = mem_operation_active $end
$var wire 32 > mem_rdata [31:0] $end
$var wire 1 / mem_ready $end
$var wire 1 ? mul_en $end
$var wire 1 @ mul_set_flags $end
$var wire 32 A reg_pc_out [31:0] $end
$var wire 1 0 rst_n $end
$var wire 1 B swap_byte $end
$var wire 1 C swi_exception $end
$var wire 1 D undefined_exception $end
$var wire 1 E write_lr $end
$var wire 1 F thumb_mode $end
$var wire 1 G swap_operation $end
$var wire 1 H shifter_carry_out $end
$var wire 32 I shifted_operand [31:0] $end
$var wire 32 J reg_spsr_out [31:0] $end
$var wire 32 K reg_rn_data [31:0] $end
$var wire 32 L reg_rm_data [31:0] $end
$var wire 32 M reg_cpsr_out [31:0] $end
$var wire 1 N mul_zero $end
$var wire 1 O mul_result_ready $end
$var wire 32 P mul_result_lo [31:0] $end
$var wire 32 Q mul_result_hi [31:0] $end
$var wire 1 R mul_negative $end
$var wire 1 S mul_long $end
$var wire 1 " mem_we $end
$var wire 32 T mem_wdata [31:0] $end
$var wire 1 $ mem_re $end
$var wire 4 U mem_be [3:0] $end
$var wire 32 V mem_address [31:0] $end
$var wire 32 W mem_addr [31:0] $end
$var wire 32 X lr_data [31:0] $end
$var wire 1 Y halfword_operation $end
$var wire 32 Z fetch_pc [31:0] $end
$var wire 1 [ fetch_mem_re $end
$var wire 32 \ fetch_mem_addr [31:0] $end
$var wire 32 ] fetch_instruction [31:0] $end
$var wire 1 ^ fetch_instr_valid $end
$var wire 32 _ exception_vector [31:0] $end
$var wire 3 ` exception_type [2:0] $end
$var wire 1 a exception_taken $end
$var wire 32 b exception_spsr [31:0] $end
$var wire 5 c exception_mode [4:0] $end
$var wire 32 d exception_cpsr [31:0] $end
$var wire 1 e decode_valid $end
$var wire 3 f decode_thumb_rs [2:0] $end
$var wire 3 g decode_thumb_rn [2:0] $end
$var wire 3 h decode_thumb_rd [2:0] $end
$var wire 8 i decode_thumb_offset8 [7:0] $end
$var wire 11 j decode_thumb_offset11 [10:0] $end
$var wire 5 k decode_thumb_instr_type [4:0] $end
$var wire 8 l decode_thumb_imm8 [7:0] $end
$var wire 5 m decode_thumb_imm5 [4:0] $end
$var wire 2 n decode_shift_type [1:0] $end
$var wire 4 o decode_shift_rs [3:0] $end
$var wire 1 p decode_shift_reg $end
$var wire 5 q decode_shift_amount [4:0] $end
$var wire 1 r decode_set_flags $end
$var wire 4 s decode_rn [3:0] $end
$var wire 4 t decode_rm [3:0] $end
$var wire 4 u decode_rd [3:0] $end
$var wire 1 v decode_psr_to_reg $end
$var wire 1 w decode_psr_spsr $end
$var wire 1 x decode_psr_immediate $end
$var wire 32 y decode_pc [31:0] $end
$var wire 1 z decode_mem_writeback $end
$var wire 1 { decode_mem_up $end
$var wire 1 | decode_mem_pre $end
$var wire 1 } decode_mem_load $end
$var wire 1 ~ decode_mem_byte $end
$var wire 1 !" decode_is_memory $end
$var wire 1 "" decode_is_branch $end
$var wire 4 #" decode_instr_type [3:0] $end
$var wire 12 $" decode_immediate [11:0] $end
$var wire 1 %" decode_imm_en $end
$var wire 4 &" decode_cp_rn [3:0] $end
$var wire 4 '" decode_cp_rd [3:0] $end
$var wire 3 (" decode_cp_opcode2 [2:0] $end
$var wire 3 )" decode_cp_opcode1 [2:0] $end
$var wire 3 *" decode_cp_op [2:0] $end
$var wire 4 +" decode_cp_num [3:0] $end
$var wire 1 ," decode_cp_load $end
$var wire 4 -" decode_condition [3:0] $end
$var wire 24 ." decode_branch_offset [23:0] $end
$var wire 1 /" decode_branch_link $end
$var wire 4 0" decode_alu_op [3:0] $end
$var wire 5 1" current_mode [4:0] $end
$var wire 1 2" condition_passed $end
$var wire 1 3" branch_exchange $end
$var wire 16 4" block_register_list [15:0] $end
$var wire 1 5" block_reg_we $end
$var wire 32 6" block_reg_wdata [31:0] $end
$var wire 4 7" block_reg_addr [3:0] $end
$var wire 1 8" block_mem_we $end
$var wire 32 9" block_mem_wdata [31:0] $end
$var wire 1 :" block_mem_re $end
$var wire 32 ;" block_mem_addr [31:0] $end
$var wire 1 <" block_complete $end
$var wire 1 =" block_base_reg_we $end
$var wire 32 >" block_base_reg_data [31:0] $end
$var wire 4 ?" block_base_reg_addr [3:0] $end
$var wire 1 @" block_active $end
$var wire 1 A" alu_zero $end
$var wire 32 B" alu_result [31:0] $end
$var wire 1 C" alu_overflow $end
$var wire 1 D" alu_negative $end
$var wire 1 E" alu_carry_out $end
$var wire 4 F" actual_rn_addr [3:0] $end
$var wire 4 G" actual_rm_addr [3:0] $end
$var wire 4 H" actual_rd_addr [3:0] $end
$var reg 1 I" alu_carry_in $end
$var reg 32 J" alu_operand_a [31:0] $end
$var reg 32 K" alu_operand_b [31:0] $end
$var reg 32 L" arm_mem_offset [31:0] $end
$var reg 1 M" branch_taken $end
$var reg 32 N" branch_target [31:0] $end
$var reg 32 O" cp_data_out [31:0] $end
$var reg 1 P" cp_exception $end
$var reg 1 Q" cp_present $end
$var reg 1 R" cp_ready $end
$var reg 3 S" current_state [2:0] $end
$var reg 4 T" data_mem_be [3:0] $end
$var reg 1 U" data_mem_re $end
$var reg 32 V" data_mem_wdata [31:0] $end
$var reg 1 W" data_mem_we $end
$var reg 4 X" effective_alu_op [3:0] $end
$var reg 5 Y" effective_shift_amount [4:0] $end
$var reg 32 Z" effective_shift_data [31:0] $end
$var reg 1 [" fetch_en $end
$var reg 1 \" flush $end
$var reg 8 ]" imm_value [7:0] $end
$var reg 32 ^" load_data [31:0] $end
$var reg 1 _" mode_change $end
$var reg 32 `" mul_acc_hi [31:0] $end
$var reg 32 a" mul_acc_lo [31:0] $end
$var reg 1 b" mul_accumulate $end
$var reg 1 c" mul_hi_write_pending $end
$var reg 1 d" mul_signed $end
$var reg 2 e" mul_type [1:0] $end
$var reg 3 f" next_state [2:0] $end
$var reg 32 g" reg_cpsr_in [31:0] $end
$var reg 1 h" reg_cpsr_we $end
$var reg 32 i" reg_pc_in [31:0] $end
$var reg 1 j" reg_pc_we $end
$var reg 32 k" reg_rd_data [31:0] $end
$var reg 1 l" reg_rd_we $end
$var reg 32 m" reg_spsr_in [31:0] $end
$var reg 1 n" reg_spsr_we $end
$var reg 5 o" rot_amount [4:0] $end
$var reg 4 p" rotate_imm [3:0] $end
$var reg 1 ! running $end
$var reg 1 q" save_lr $end
$var reg 1 r" stall $end
$var reg 2 s" swap_next_state [1:0] $end
$var reg 32 t" swap_read_data [31:0] $end
$var reg 2 u" swap_state [1:0] $end
$var reg 5 v" target_mode [4:0] $end
$var reg 1 w" thumb_alu_carry_out $end
$var reg 1 x" thumb_alu_negative $end
$var reg 1 y" thumb_alu_overflow $end
$var reg 32 z" thumb_alu_result [31:0] $end
$var reg 1 {" thumb_alu_zero $end
$var reg 1 |" thumb_bl_pending $end
$var reg 32 }" thumb_bl_target [31:0] $end
$var reg 32 ~" thumb_mem_address [31:0] $end
$var reg 1 !# thumb_switch $end
$scope function evaluate_condition $end
$var reg 1 "# c $end
$var reg 4 ## cond [3:0] $end
$var reg 1 $# n $end
$var reg 1 %# v $end
$var reg 1 &# z $end
$upscope $end
$scope module u_alu $end
$var wire 4 '# alu_op [3:0] $end
$var wire 1 I" carry_in $end
$var wire 1 E" carry_out $end
$var wire 1 ) clk $end
$var wire 32 (# operand_a [31:0] $end
$var wire 32 )# operand_b [31:0] $end
$var wire 1 C" overflow $end
$var wire 32 *# result [31:0] $end
$var wire 1 0 rst_n $end
$var wire 1 A" zero $end
$var wire 1 r set_flags $end
$var wire 1 D" negative $end
$var reg 1 +# alu_carry $end
$var reg 1 ,# alu_overflow $end
$var reg 32 -# alu_result [31:0] $end
$var reg 33 .# extended_result [32:0] $end
$upscope $end
$scope module u_block_dt $end
$var wire 32 /# base_address [31:0] $end
$var wire 4 0# base_reg_addr [3:0] $end
$var wire 4 1# base_register [3:0] $end
$var wire 1 3 block_en $end
$var wire 1 4 block_load $end
$var wire 1 5 block_pre $end
$var wire 1 7 block_up $end
$var wire 1 8 block_user_mode $end
$var wire 1 9 block_writeback $end
$var wire 1 ) clk $end
$var wire 32 2# mem_addr [31:0] $end
$var wire 32 3# mem_rdata [31:0] $end
$var wire 1 :" mem_re $end
$var wire 1 / mem_ready $end
$var wire 32 4# mem_wdata [31:0] $end
$var wire 1 8" mem_we $end
$var wire 4 5# reg_addr [3:0] $end
$var wire 32 6# reg_rdata [31:0] $end
$var wire 32 7# reg_wdata [31:0] $end
$var wire 1 5" reg_we $end
$var wire 16 8# register_list [15:0] $end
$var wire 1 0 rst_n $end
$var wire 1 <" block_complete $end
$var wire 1 @" block_active $end
$var wire 1 =" base_reg_we $end
$var reg 32 9# base_reg_data [31:0] $end
$var reg 32 :# current_addr [31:0] $end
$var reg 4 ;# current_reg [3:0] $end
$var reg 1 <# first_transfer $end
$var reg 4 =# next_reg [3:0] $end
$var reg 3 ># next_state [2:0] $end
$var reg 5 ?# reg_count [4:0] $end
$var reg 16 @# remaining_regs [15:0] $end
$var reg 3 A# state [2:0] $end
$var reg 5 B# total_regs [4:0] $end
$scope begin $ivl_for_loop3 $end
$var integer 32 C# i [31:0] $end
$upscope $end
$scope begin $ivl_for_loop4 $end
$var integer 32 D# i [31:0] $end
$upscope $end
$upscope $end
$scope module u_decode $end
$var wire 1 /" branch_link $end
$var wire 24 E# branch_offset [23:0] $end
$var wire 1 ) clk $end
$var wire 4 F# condition [3:0] $end
$var wire 1 \" flush $end
$var wire 1 %" imm_en $end
$var wire 12 G# immediate [11:0] $end
$var wire 1 !" is_memory $end
$var wire 1 ~ mem_byte $end
$var wire 1 } mem_load $end
$var wire 1 | mem_pre $end
$var wire 1 { mem_up $end
$var wire 1 z mem_writeback $end
$var wire 1 x psr_immediate $end
$var wire 1 w psr_spsr $end
$var wire 1 v psr_to_reg $end
$var wire 4 H# rd [3:0] $end
$var wire 4 I# rm [3:0] $end
$var wire 4 J# rn [3:0] $end
$var wire 1 0 rst_n $end
$var wire 1 r set_flags $end
$var wire 1 p shift_reg $end
$var wire 2 K# shift_type [1:0] $end
$var wire 1 r" stall $end
$var wire 1 F thumb_mode $end
$var wire 1 L# w_bit $end
$var wire 1 M# u_bit $end
$var wire 2 N# shift_type_field [1:0] $end
$var wire 4 O# shift_rs [3:0] $end
$var wire 5 P# shift_amt_field [4:0] $end
$var wire 5 Q# shift_amount [4:0] $end
$var wire 1 R# s_bit $end
$var wire 4 S# rn_field [3:0] $end
$var wire 4 T# rm_field [3:0] $end
$var wire 4 U# rd_field [3:0] $end
$var wire 32 V# pc_out [31:0] $end
$var wire 32 W# pc_in [31:0] $end
$var wire 1 X# p_bit $end
$var wire 6 Y# op_code [5:0] $end
$var wire 2 Z# op_class [1:0] $end
$var wire 1 [# l_bit_mem $end
$var wire 1 \# l_bit $end
$var wire 1 "" is_branch $end
$var wire 32 ]# instruction [31:0] $end
$var wire 1 ^ instr_valid $end
$var wire 12 ^# imm_field [11:0] $end
$var wire 1 _# i_bit $end
$var wire 1 e decode_valid $end
$var wire 4 `# cond_field [3:0] $end
$var wire 24 a# branch_offset_field [23:0] $end
$var wire 1 b# b_bit $end
$var wire 4 c# alu_op [3:0] $end
$var reg 1 ," cp_load $end
$var reg 4 d# cp_num [3:0] $end
$var reg 3 e# cp_op [2:0] $end
$var reg 3 f# cp_opcode1 [2:0] $end
$var reg 3 g# cp_opcode2 [2:0] $end
$var reg 4 h# cp_rd [3:0] $end
$var reg 4 i# cp_rn [3:0] $end
$var reg 4 j# instr_type [3:0] $end
$var reg 32 k# pc_reg [31:0] $end
$var reg 5 l# thumb_imm5 [4:0] $end
$var reg 8 m# thumb_imm8 [7:0] $end
$var reg 5 n# thumb_instr_type [4:0] $end
$var reg 11 o# thumb_offset11 [10:0] $end
$var reg 8 p# thumb_offset8 [7:0] $end
$var reg 3 q# thumb_rd [2:0] $end
$var reg 3 r# thumb_rn [2:0] $end
$var reg 3 s# thumb_rs [2:0] $end
$var reg 1 e valid_reg $end
$upscope $end
$scope module u_exception $end
$var wire 1 ) clk $end
$var wire 5 t# current_mode [4:0] $end
$var wire 32 u# current_pc [31:0] $end
$var wire 1 v# data_abort $end
$var wire 32 w# exception_spsr [31:0] $end
$var wire 1 + fiq $end
$var wire 1 - irq $end
$var wire 1 x# prefetch_abort $end
$var wire 1 0 rst_n $end
$var wire 1 C swi $end
$var wire 1 D undefined_instr $end
$var wire 1 y# irq_disabled $end
$var wire 1 z# fiq_disabled $end
$var wire 32 {# current_cpsr [31:0] $end
$var reg 32 |# exception_cpsr [31:0] $end
$var reg