$date
	Thu Jul 24 09:40:57 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module simple_tb $end
$var wire 4 ! mem_be [3:0] $end
$var wire 32 " mem_rdata [31:0] $end
$var wire 1 # mem_ready $end
$var wire 32 $ mem_wdata [31:0] $end
$var wire 1 % mem_we $end
$var wire 1 & running $end
$var wire 1 ' mem_re $end
$var wire 32 ( mem_addr [31:0] $end
$var wire 32 ) debug_pc [31:0] $end
$var wire 32 * debug_instr [31:0] $end
$var reg 1 + clk $end
$var reg 1 , debug_en $end
$var reg 1 - fiq $end
$var reg 1 . halt $end
$var reg 1 / irq $end
$var reg 1 0 rst_n $end
$scope module dut $end
$var wire 1 + clk $end
$var wire 1 , debug_en $end
$var wire 32 1 debug_instr [31:0] $end
$var wire 32 2 debug_pc [31:0] $end
$var wire 1 - fiq $end
$var wire 1 . halt $end
$var wire 1 / irq $end
$var wire 4 3 mem_be [3:0] $end
$var wire 32 4 mem_rdata [31:0] $end
$var wire 1 # mem_ready $end
$var wire 32 5 mem_wdata [31:0] $end
$var wire 1 % mem_we $end
$var wire 32 6 reg_pc_out [31:0] $end
$var wire 1 0 rst_n $end
$var wire 1 7 thumb_mode $end
$var wire 32 8 reg_spsr_out [31:0] $end
$var wire 32 9 reg_rn_data [31:0] $end
$var wire 32 : reg_rm_data [31:0] $end
$var wire 32 ; reg_cpsr_out [31:0] $end
$var wire 1 ' mem_re $end
$var wire 32 < mem_addr [31:0] $end
$var wire 32 = fetch_pc [31:0] $end
$var wire 32 > fetch_instruction [31:0] $end
$var wire 1 ? fetch_instr_valid $end
$var wire 1 @ decode_valid $end
$var wire 2 A decode_shift_type [1:0] $end
$var wire 5 B decode_shift_amount [4:0] $end
$var wire 1 C decode_set_flags $end
$var wire 4 D decode_rn [3:0] $end
$var wire 4 E decode_rm [3:0] $end
$var wire 4 F decode_rd [3:0] $end
$var wire 32 G decode_pc [31:0] $end
$var wire 1 H decode_mem_writeback $end
$var wire 1 I decode_mem_up $end
$var wire 1 J decode_mem_pre $end
$var wire 1 K decode_mem_load $end
$var wire 1 L decode_mem_byte $end
$var wire 1 M decode_is_memory $end
$var wire 1 N decode_is_branch $end
$var wire 4 O decode_instr_type [3:0] $end
$var wire 12 P decode_immediate [11:0] $end
$var wire 1 Q decode_imm_en $end
$var wire 4 R decode_condition [3:0] $end
$var wire 24 S decode_branch_offset [23:0] $end
$var wire 1 T decode_branch_link $end
$var wire 4 U decode_alu_op [3:0] $end
$var wire 5 V current_mode [4:0] $end
$var wire 1 W alu_zero $end
$var wire 32 X alu_result [31:0] $end
$var wire 1 Y alu_overflow $end
$var wire 1 Z alu_negative $end
$var wire 1 [ alu_carry_out $end
$var reg 1 \ alu_carry_in $end
$var reg 32 ] alu_operand_a [31:0] $end
$var reg 32 ^ alu_operand_b [31:0] $end
$var reg 1 _ branch_taken $end
$var reg 32 ` branch_target [31:0] $end
$var reg 3 a current_state [2:0] $end
$var reg 1 b fetch_en $end
$var reg 1 c flush $end
$var reg 1 d mode_change $end
$var reg 3 e next_state [2:0] $end
$var reg 32 f reg_cpsr_in [31:0] $end
$var reg 1 g reg_cpsr_we $end
$var reg 32 h reg_pc_in [31:0] $end
$var reg 1 i reg_pc_we $end
$var reg 32 j reg_rd_data [31:0] $end
$var reg 1 k reg_rd_we $end
$var reg 32 l reg_spsr_in [31:0] $end
$var reg 1 m reg_spsr_we $end
$var reg 1 & running $end
$var reg 1 n stall $end
$var reg 5 o target_mode [4:0] $end
$scope module u_alu $end
$var wire 1 \ carry_in $end
$var wire 1 [ carry_out $end
$var wire 1 + clk $end
$var wire 32 p operand_a [31:0] $end
$var wire 32 q operand_b [31:0] $end
$var wire 1 Y overflow $end
$var wire 32 r result [31:0] $end
$var wire 1 0 rst_n $end
$var wire 1 W zero $end
$var wire 1 C set_flags $end
$var wire 1 Z negative $end
$var wire 4 s alu_op [3:0] $end
$var reg 1 t alu_carry $end
$var reg 1 u alu_overflow $end
$var reg 32 v alu_result [31:0] $end
$var reg 33 w extended_result [32:0] $end
$upscope $end
$scope module u_decode $end
$var wire 1 T branch_link $end
$var wire 24 x branch_offset [23:0] $end
$var wire 1 + clk $end
$var wire 4 y condition [3:0] $end
$var wire 1 @ decode_valid $end
$var wire 1 c flush $end
$var wire 1 Q imm_en $end
$var wire 12 z immediate [11:0] $end
$var wire 1 M is_memory $end
$var wire 1 L mem_byte $end
$var wire 1 K mem_load $end
$var wire 1 J mem_pre $end
$var wire 1 I mem_up $end
$var wire 1 H mem_writeback $end
$var wire 32 { pc_out [31:0] $end
$var wire 4 | rd [3:0] $end
$var wire 4 } rm [3:0] $end
$var wire 4 ~ rn [3:0] $end
$var wire 1 0 rst_n $end
$var wire 1 C set_flags $end
$var wire 5 !" shift_amount [4:0] $end
$var wire 2 "" shift_type [1:0] $end
$var wire 1 n stall $end
$var wire 1 7 thumb_mode $end
$var wire 1 #" w_bit $end
$var wire 1 $" u_bit $end
$var wire 2 %" shift_type_field [1:0] $end
$var wire 5 &" shift_amt_field [4:0] $end
$var wire 1 '" s_bit $end
$var wire 4 (" rn_field [3:0] $end
$var wire 4 )" rm_field [3:0] $end
$var wire 4 *" rd_field [3:0] $end
$var wire 32 +" pc_in [31:0] $end
$var wire 1 ," p_bit $end
$var wire 6 -" op_code [5:0] $end
$var wire 2 ." op_class [1:0] $end
$var wire 1 /" l_bit_mem $end
$var wire 1 0" l_bit $end
$var wire 1 N is_branch $end
$var wire 32 1" instruction [31:0] $end
$var wire 1 ? instr_valid $end
$var wire 12 2" imm_field [11:0] $end
$var wire 1 3" i_bit $end
$var wire 4 4" cond_field [3:0] $end
$var wire 24 5" branch_offset_field [23:0] $end
$var wire 1 6" b_bit $end
$var wire 4 7" alu_op [3:0] $end
$var reg 4 8" instr_type [3:0] $end
$var reg 32 9" pc_reg [31:0] $end
$var reg 1 :" valid_reg $end
$upscope $end
$scope module u_fetch $end
$var wire 1 _ branch_taken $end
$var wire 32 ;" branch_target [31:0] $end
$var wire 1 + clk $end
$var wire 1 b fetch_en $end
$var wire 1 c flush $end
$var wire 1 ? instr_valid $end
$var wire 32 <" instruction [31:0] $end
$var wire 32 =" mem_rdata [31:0] $end
$var wire 1 # mem_ready $end
$var wire 32 >" pc_out [31:0] $end
$var wire 1 0 rst_n $end
$var wire 1 n stall $end
$var wire 1 7 thumb_mode $end
$var reg 2 ?" current_state [1:0] $end
$var reg 32 @" instr_buffer [31:0] $end
$var reg 1 A" instr_ready $end
$var reg 32 B" mem_addr [31:0] $end
$var reg 1 ' mem_re $end
$var reg 2 C" next_state [1:0] $end
$var reg 32 D" pc [31:0] $end
$upscope $end
$scope module u_regfile $end
$var wire 1 + clk $end
$var wire 32 E" cpsr_in [31:0] $end
$var wire 32 F" cpsr_out [31:0] $end
$var wire 1 g cpsr_we $end
$var wire 5 G" current_mode [4:0] $end
$var wire 1 d mode_change $end
$var wire 32 H" pc_in [31:0] $end
$var wire 32 I" pc_out [31:0] $end
$var wire 1 i pc_we $end
$var wire 4 J" rd_addr [3:0] $end
$var wire 32 K" rd_data [31:0] $end
$var wire 1 k rd_we $end
$var wire 4 L" rm_addr [3:0] $end
$var wire 32 M" rm_data [31:0] $end
$var wire 4 N" rn_addr [3:0] $end
$var wire 32 O" rn_data [31:0] $end
$var wire 1 0 rst_n $end
$var wire 32 P" spsr_in [31:0] $end
$var wire 32 Q" spsr_out [31:0] $end
$var wire 1 m spsr_we $end
$var wire 5 R" target_mode [4:0] $end
$var reg 32 S" cpsr [31:0] $end
$var reg 32 T" current_spsr [31:0] $end
$var reg 32 U" rm_data_internal [31:0] $end
$var reg 32 V" rn_data_internal [31:0] $end
$var reg 32 W" spsr_abt [31:0] $end
$var reg 32 X" spsr_fiq [31:0] $end
$var reg 32 Y" spsr_irq [31:0] $end
$var reg 32 Z" spsr_svc [31:0] $end
$var reg 32 [" spsr_und [31:0] $end
$scope begin $ivl_for_loop0 $end
$var integer 32 \" i [31:0] $end
$upscope $end
$scope begin $ivl_for_loop1 $end
$var integer 32 ]" i [31:0] $end
$upscope $end
$scope begin $ivl_for_loop2 $end
$var integer 32 ^" i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b1111 ^"
b1111 ]"
b10000 \"
b0 ["
b0 Z"
b0 Y"
b0 X"
b0 W"
b0 V"
b0 U"
b0 T"
b10011 S"
b10011 R"
b0 Q"
b0 P"
b0 O"
b0 N"
b0 M"
b0 L"
b0 K"
b0 J"
b0 I"
b0 H"
b10011 G"
b10011 F"
b10011 E"
b0 D"
b1 C"
b0 B"
0A"
b0 @"
b0 ?"
b0 >"
b11100001101000000000000000000000 ="
b0 <"
b0 ;"
0:"
b0 9"
b0 8"
b0 7"
06"
b0 5"
b0 4"
03"
b0 2"
b0 1"
00"
0/"
b0 ."
b0 -"
0,"
b0 +"
b0 *"
b0 )"
b0 ("
0'"
b0 &"
b0 %"
0$"
0#"
b0 ""
b0 !"
b0 ~
b0 }
b0 |
b0 {
b0 z
b0 y
b0 x
b0 w
b0 v
0u
0t
b0 s
b0 r
b0 q
b0 p
b10011 o
0n
0m
b0 l
0k
b0 j
0i
b0 h
0g
b10011 f
b0 e
0d
0c
1b
b0 a
b0 `
0_
b0 ^
b0 ]
0\
0[
0Z
0Y
b0 X
1W
b10011 V
b0 U
0T
b0 S
b0 R
0Q
b0 P
b0 O
0N
0M
0L
0K
0J
0I
0H
b0 G
b0 F
b0 E
b0 D
0C
b0 B
b0 A
0@
0?
b0 >
b0 =
b0 <
b10011 ;
b0 :
b0 9
b0 8
07
b0 6
b0 5
b11100001101000000000000000000000 4
b1111 3
b0 2
b0 1
00
0/
0.
0-
1,
0+
b0 *
b0 )
b0 (
1'
0&
0%
b0 $
1#
b11100001101000000000000000000000 "
b1111 !
$end
#5
b1111 ^"
b1111 ]"
b10000 \"
1+
#10
0+
#15
b1111 ^"
b1111 ]"
b10000 \"
1+
#20
0+
#25
b1111 ^"
b1111 ]"
b10000 \"
1+
#30
0+
#35
b1111 ^"
b1111 ]"
b10000 \"
1+
#40
0+
#45
b1111 ^"
b1111 ]"
b10000 \"
1+
#50
0+
10
#55
b100 (
b100 <
b100 B"
b10 C"
b100 =
b100 +"
b100 >"
b100 D"
b1 ?"
1&
1+
#60
0+
#65
b1 e
1b
b1101 U
b1101 s
b1101 7"
1H
1#"
1I
1$"
1J
1,"
b101000000000000000000000 S
b101000000000000000000000 x
b101000000000000000000000 5"
10"
b110100 -"
b1110 R
b1110 y
b1110 4"
b0 O
b0 8"
1?
b1 C"
0'
b1000 (
b1000 <
b1000 B"
b100 G
b100 {
b100 9"
1A"
b11100001101000000000000000000000 *
b11100001101000000000000000000000 1
b11100001101000000000000000000000 >
b11100001101000000000000000000000 1"
b11100001101000000000000000000000 <"
b11100001101000000000000000000000 @"
b10 ?"
b1000 =
b1000 +"
b1000 >"
b1000 D"
1+
#70
0+
#75
0?
b10 C"
1'
b1100 (
b1100 <
b1100 B"
b0 O
b0 8"
b10 e
0b
b1100 =
b1100 +"
b1100 >"
b1100 D"
b1 ?"
0A"
1@
1:"
b1000 G
b1000 {
b1000 9"
b1 a
1+
#80
0+
#85
b0 O
b0 8"
b11 e
0'
b0 C"
1?
b10 a
0@
0:"
b1100 G
b1100 {
b1100 9"
1A"
b10 ?"
1+
#90
0+
#95
0?
b0 O
b0 8"
b100 e
b0 ?"
0A"
1@
1:"
b11 a
1+
