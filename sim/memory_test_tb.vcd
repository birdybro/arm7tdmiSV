$date
	Thu Jul 24 19:27:13 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module memory_test_tb $end
$var wire 1 ! mem_ready $end
$var wire 1 " mem_we $end
$var wire 32 # mem_wdata [31:0] $end
$var wire 1 $ mem_re $end
$var wire 32 % mem_rdata [31:0] $end
$var wire 4 & mem_be [3:0] $end
$var wire 32 ' mem_addr [31:0] $end
$var wire 32 ( debug_pc [31:0] $end
$var wire 32 ) debug_instr [31:0] $end
$var reg 32 * actual_mem_data [31:0] $end
$var reg 1 + clk $end
$var reg 1 , debug_en $end
$var reg 32 - mov_instr [31:0] $end
$var reg 1 . rst_n $end
$var reg 1 / test_passed $end
$var integer 32 0 tests_passed [31:0] $end
$var integer 32 1 tests_run [31:0] $end
$scope module u_dut $end
$var wire 32 2 block_base_address [31:0] $end
$var wire 4 3 block_base_register [3:0] $end
$var wire 1 4 block_en $end
$var wire 1 5 block_load $end
$var wire 1 6 block_pre $end
$var wire 32 7 block_reg_rdata [31:0] $end
$var wire 1 8 block_up $end
$var wire 1 9 block_user_mode $end
$var wire 1 : block_writeback $end
$var wire 1 + clk $end
$var wire 32 ; data_mem_addr [31:0] $end
$var wire 1 , debug_en $end
$var wire 32 < debug_instr [31:0] $end
$var wire 32 = debug_pc [31:0] $end
$var wire 1 > fiq $end
$var wire 1 ? halt $end
$var wire 1 @ irq $end
$var wire 1 A mem_operation_active $end
$var wire 32 B mem_rdata [31:0] $end
$var wire 1 ! mem_ready $end
$var wire 1 C mul_en $end
$var wire 1 D mul_set_flags $end
$var wire 32 E reg_pc_out [31:0] $end
$var wire 1 . rst_n $end
$var wire 1 F swap_byte $end
$var wire 1 G swi_exception $end
$var wire 1 H undefined_exception $end
$var wire 1 I write_lr $end
$var wire 1 J thumb_mode $end
$var wire 1 K swap_operation $end
$var wire 1 L shifter_carry_out $end
$var wire 32 M shifted_operand [31:0] $end
$var wire 32 N reg_spsr_out [31:0] $end
$var wire 32 O reg_rn_data [31:0] $end
$var wire 32 P reg_rm_data [31:0] $end
$var wire 32 Q reg_cpsr_out [31:0] $end
$var wire 1 R mul_zero $end
$var wire 1 S mul_result_ready $end
$var wire 32 T mul_result_lo [31:0] $end
$var wire 32 U mul_result_hi [31:0] $end
$var wire 1 V mul_negative $end
$var wire 1 W mul_long $end
$var wire 1 " mem_we $end
$var wire 32 X mem_wdata [31:0] $end
$var wire 1 $ mem_re $end
$var wire 4 Y mem_be [3:0] $end
$var wire 32 Z mem_address [31:0] $end
$var wire 32 [ mem_addr [31:0] $end
$var wire 32 \ lr_data [31:0] $end
$var wire 1 ] halfword_operation $end
$var wire 32 ^ fetch_pc [31:0] $end
$var wire 1 _ fetch_mem_re $end
$var wire 32 ` fetch_mem_addr [31:0] $end
$var wire 32 a fetch_instruction [31:0] $end
$var wire 1 b fetch_instr_valid $end
$var wire 32 c exception_vector [31:0] $end
$var wire 3 d exception_type [2:0] $end
$var wire 1 e exception_taken $end
$var wire 32 f exception_spsr [31:0] $end
$var wire 5 g exception_mode [4:0] $end
$var wire 32 h exception_cpsr [31:0] $end
$var wire 1 i decode_valid $end
$var wire 3 j decode_thumb_rs [2:0] $end
$var wire 3 k decode_thumb_rn [2:0] $end
$var wire 3 l decode_thumb_rd [2:0] $end
$var wire 8 m decode_thumb_offset8 [7:0] $end
$var wire 11 n decode_thumb_offset11 [10:0] $end
$var wire 5 o decode_thumb_instr_type [4:0] $end
$var wire 8 p decode_thumb_imm8 [7:0] $end
$var wire 5 q decode_thumb_imm5 [4:0] $end
$var wire 2 r decode_shift_type [1:0] $end
$var wire 4 s decode_shift_rs [3:0] $end
$var wire 1 t decode_shift_reg $end
$var wire 5 u decode_shift_amount [4:0] $end
$var wire 1 v decode_set_flags $end
$var wire 4 w decode_rn [3:0] $end
$var wire 4 x decode_rm [3:0] $end
$var wire 4 y decode_rd [3:0] $end
$var wire 1 z decode_psr_to_reg $end
$var wire 1 { decode_psr_spsr $end
$var wire 1 | decode_psr_immediate $end
$var wire 32 } decode_pc [31:0] $end
$var wire 1 ~ decode_mem_writeback $end
$var wire 1 !" decode_mem_up $end
$var wire 1 "" decode_mem_pre $end
$var wire 1 #" decode_mem_load $end
$var wire 1 $" decode_mem_byte $end
$var wire 1 %" decode_is_memory $end
$var wire 1 &" decode_is_branch $end
$var wire 4 '" decode_instr_type [3:0] $end
$var wire 12 (" decode_immediate [11:0] $end
$var wire 1 )" decode_imm_en $end
$var wire 4 *" decode_cp_rn [3:0] $end
$var wire 4 +" decode_cp_rd [3:0] $end
$var wire 3 ," decode_cp_opcode2 [2:0] $end
$var wire 3 -" decode_cp_opcode1 [2:0] $end
$var wire 3 ." decode_cp_op [2:0] $end
$var wire 4 /" decode_cp_num [3:0] $end
$var wire 1 0" decode_cp_load $end
$var wire 4 1" decode_condition [3:0] $end
$var wire 24 2" decode_branch_offset [23:0] $end
$var wire 1 3" decode_branch_link $end
$var wire 4 4" decode_alu_op [3:0] $end
$var wire 5 5" current_mode [4:0] $end
$var wire 1 6" condition_passed $end
$var wire 1 7" branch_exchange $end
$var wire 16 8" block_register_list [15:0] $end
$var wire 1 9" block_reg_we $end
$var wire 32 :" block_reg_wdata [31:0] $end
$var wire 4 ;" block_reg_addr [3:0] $end
$var wire 1 <" block_mem_we $end
$var wire 32 =" block_mem_wdata [31:0] $end
$var wire 1 >" block_mem_re $end
$var wire 32 ?" block_mem_addr [31:0] $end
$var wire 1 @" block_complete $end
$var wire 1 A" block_base_reg_we $end
$var wire 32 B" block_base_reg_data [31:0] $end
$var wire 4 C" block_base_reg_addr [3:0] $end
$var wire 1 D" block_active $end
$var wire 1 E" alu_zero $end
$var wire 32 F" alu_result [31:0] $end
$var wire 1 G" alu_overflow $end
$var wire 1 H" alu_negative $end
$var wire 1 I" alu_carry_out $end
$var wire 4 J" actual_rn_addr [3:0] $end
$var wire 4 K" actual_rm_addr [3:0] $end
$var wire 4 L" actual_rd_addr [3:0] $end
$var reg 1 M" alu_carry_in $end
$var reg 32 N" alu_operand_a [31:0] $end
$var reg 32 O" alu_operand_b [31:0] $end
$var reg 32 P" arm_mem_offset [31:0] $end
$var reg 1 Q" branch_taken $end
$var reg 32 R" branch_target [31:0] $end
$var reg 32 S" cp_data_out [31:0] $end
$var reg 1 T" cp_exception $end
$var reg 1 U" cp_present $end
$var reg 1 V" cp_ready $end
$var reg 3 W" current_state [2:0] $end
$var reg 4 X" data_mem_be [3:0] $end
$var reg 1 Y" data_mem_re $end
$var reg 32 Z" data_mem_wdata [31:0] $end
$var reg 1 [" data_mem_we $end
$var reg 4 \" effective_alu_op [3:0] $end
$var reg 5 ]" effective_shift_amount [4:0] $end
$var reg 32 ^" effective_shift_data [31:0] $end
$var reg 1 _" fetch_en $end
$var reg 1 `" flush $end
$var reg 8 a" imm_value [7:0] $end
$var reg 32 b" load_data [31:0] $end
$var reg 1 c" mode_change $end
$var reg 32 d" mul_acc_hi [31:0] $end
$var reg 32 e" mul_acc_lo [31:0] $end
$var reg 1 f" mul_accumulate $end
$var reg 1 g" mul_hi_write_pending $end
$var reg 1 h" mul_signed $end
$var reg 2 i" mul_type [1:0] $end
$var reg 3 j" next_state [2:0] $end
$var reg 32 k" reg_cpsr_in [31:0] $end
$var reg 1 l" reg_cpsr_we $end
$var reg 32 m" reg_pc_in [31:0] $end
$var reg 1 n" reg_pc_we $end
$var reg 32 o" reg_rd_data [31:0] $end
$var reg 1 p" reg_rd_we $end
$var reg 32 q" reg_spsr_in [31:0] $end
$var reg 1 r" reg_spsr_we $end
$var reg 5 s" rot_amount [4:0] $end
$var reg 4 t" rotate_imm [3:0] $end
$var reg 1 u" running $end
$var reg 1 v" save_lr $end
$var reg 1 w" stall $end
$var reg 2 x" swap_next_state [1:0] $end
$var reg 32 y" swap_read_data [31:0] $end
$var reg 2 z" swap_state [1:0] $end
$var reg 5 {" target_mode [4:0] $end
$var reg 1 |" thumb_alu_carry_out $end
$var reg 1 }" thumb_alu_negative $end
$var reg 1 ~" thumb_alu_overflow $end
$var reg 32 !# thumb_alu_result [31:0] $end
$var reg 1 "# thumb_alu_zero $end
$var reg 1 ## thumb_bl_pending $end
$var reg 32 $# thumb_bl_target [31:0] $end
$var reg 32 %# thumb_mem_address [31:0] $end
$var reg 1 &# thumb_switch $end
$scope function evaluate_condition $end
$var reg 1 '# c $end
$var reg 4 (# cond [3:0] $end
$var reg 1 )# n $end
$var reg 1 *# v $end
$var reg 1 +# z $end
$upscope $end
$scope module u_alu $end
$var wire 4 ,# alu_op [3:0] $end
$var wire 1 M" carry_in $end
$var wire 1 I" carry_out $end
$var wire 1 + clk $end
$var wire 32 -# operand_a [31:0] $end
$var wire 32 .# operand_b [31:0] $end
$var wire 1 G" overflow $end
$var wire 32 /# result [31:0] $end
$var wire 1 . rst_n $end
$var wire 1 E" zero $end
$var wire 1 v set_flags $end
$var wire 1 H" negative $end
$var reg 1 0# alu_carry $end
$var reg 1 1# alu_overflow $end
$var reg 32 2# alu_result [31:0] $end
$var reg 33 3# extended_result [32:0] $end
$upscope $end
$scope module u_block_dt $end
$var wire 32 4# base_address [31:0] $end
$var wire 4 5# base_reg_addr [3:0] $end
$var wire 4 6# base_register [3:0] $end
$var wire 1 4 block_en $end
$var wire 1 5 block_load $end
$var wire 1 6 block_pre $end
$var wire 1 8 block_up $end
$var wire 1 9 block_user_mode $end
$var wire 1 : block_writeback $end
$var wire 1 + clk $end
$var wire 32 7# mem_addr [31:0] $end
$var wire 32 8# mem_rdata [31:0] $end
$var wire 1 >" mem_re $end
$var wire 1 ! mem_ready $end
$var wire 32 9# mem_wdata [31:0] $end
$var wire 1 <" mem_we $end
$var wire 4 :# reg_addr [3:0] $end
$var wire 32 ;# reg_rdata [31:0] $end
$var wire 32 <# reg_wdata [31:0] $end
$var wire 1 9" reg_we $end
$var wire 16 =# register_list [15:0] $end
$var wire 1 . rst_n $end
$var wire 1 @" block_complete $end
$var wire 1 D" block_active $end
$var wire 1 A" base_reg_we $end
$var reg 32 ># base_reg_data [31:0] $end
$var reg 32 ?# current_addr [31:0] $end
$var reg 4 @# current_reg [3:0] $end
$var reg 1 A# first_transfer $end
$var reg 4 B# next_reg [3:0] $end
$var reg 3 C# next_state [2:0] $end
$var reg 5 D# reg_count [4:0] $end
$var reg 16 E# remaining_regs [15:0] $end
$var reg 3 F# state [2:0] $end
$var reg 5 G# total_regs [4:0] $end
$scope begin $ivl_for_loop3 $end
$var integer 32 H# i [31:0] $end
$upscope $end
$scope begin $ivl_for_loop4 $end
$var integer 32 I# i [31:0] $end
$upscope $end
$upscope $end
$scope module u_decode $end
$var wire 1 3" branch_link $end
$var wire 24 J# branch_offset [23:0] $end
$var wire 1 + clk $end
$var wire 4 K# condition [3:0] $end
$var wire 1 `" flush $end
$var wire 1 )" imm_en $end
$var wire 12 L# immediate [11:0] $end
$var wire 1 %" is_memory $end
$var wire 1 $" mem_byte $end
$var wire 1 #" mem_load $end
$var wire 1 "" mem_pre $end
$var wire 1 !" mem_up $end
$var wire 1 ~ mem_writeback $end
$var wire 1 | psr_immediate $end
$var wire 1 { psr_spsr $end
$var wire 1 z psr_to_reg $end
$var wire 4 M# rd [3:0] $end
$var wire 4 N# rm [3:0] $end
$var wire 4 O# rn [3:0] $end
$var wire 1 . rst_n $end
$var wire 1 v set_flags $end
$var wire 1 t shift_reg $end
$var wire 2 P# shift_type [1:0] $end
$var wire 1 w" stall $end
$var wire 1 J thumb_mode $end
$var wire 1 Q# w_bit $end
$var wire 1 R# u_bit $end
$var wire 2 S# shift_type_field [1:0] $end
$var wire 4 T# shift_rs [3:0] $end
$var wire 5 U# shift_amt_field [4:0] $end
$var wire 5 V# shift_amount [4:0] $end
$var wire 1 W# s_bit $end
$var wire 4 X# rn_field [3:0] $end
$var wire 4 Y# rm_field [3:0] $end
$var wire 4 Z# rd_field [3:0] $end
$var wire 32 [# pc_out [31:0] $end
$var wire 32 \# pc_in [31:0] $end
$var wire 1 ]# p_bit $end
$var wire 6 ^# op_code [5:0] $end
$var wire 2 _# op_class [1:0] $end
$var wire 1 `# l_bit_mem $end
$var wire 1 a# l_bit $end
$var wire 1 &" is_branch $end
$var wire 32 b# instruction [31:0] $end
$var wire 1 b instr_valid $end
$var wire 12 c# imm_field [11:0] $end
$var wire 1 d# i_bit $end
$var wire 1 i decode_valid $end
$var wire 4 e# cond_field [3:0] $end
$var wire 24 f# branch_offset_field [23:0] $end
$var wire 1 g# b_bit $end
$var wire 4 h# alu_op [3:0] $end
$var reg 1 0" cp_load $end
$var reg 4 i# cp_num [3:0] $end
$var reg 3 j# cp_op [2:0] $end
$var reg 3 k# cp_opcode1 [2:0] $end
$var reg 3 l# cp_opcode2 [2:0] $end
$var reg 4 m# cp_rd [3:0] $end
$var reg 4 n# cp_rn [3:0] $end
$var reg 4 o# instr_type [3:0] $end
$var reg 32 p# pc_reg [31:0] $end
$var reg 5 q# thumb_imm5 [4:0] $end
$var reg 8 r# thumb_imm8 [7:0] $end
$var reg 5 s# thumb_instr_type [4:0] $end
$var reg 11 t# thumb_offset11 [10:0] $end
$var reg 8 u# thumb_offset8 [7:0] $end
$var reg 3 v# thumb_rd [2:0] $end
$var reg 3 w# thumb_rn [2:0] $end
$var reg 3 x# thumb_rs [2:0] $end
$var reg 1 i valid_reg $end
$upscope $end
$scope module u_exception $end
$var wire 1 + clk $end
$var wire 5 y# current_mode [4:0] $end
$var wire 32 z# current_pc [31:0] $end
$var wire 1 {# data_abort $end
$var wire 32 |# exception_spsr [31:0] $end
$var wire 1 > fiq $end
$var wire 1 @ irq $end
$var wire 1 }# prefetch_abort $end
$var wire 1 . rst_n $end
$var wire 1 G swi $end
$var wire 1 H undefined_instr $end
$var wire 1 ~# irq_disabled $end
$var wire 1 !$ fiq