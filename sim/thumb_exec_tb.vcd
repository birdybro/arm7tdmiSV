$date
	Thu Jul 24 14:58:38 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module thumb_exec_tb $end
$var wire 1 ! mem_ready $end
$var wire 1 " running $end
$var wire 1 # mem_we $end
$var wire 32 $ mem_wdata [31:0] $end
$var wire 1 % mem_re $end
$var wire 4 & mem_be [3:0] $end
$var wire 32 ' mem_addr [31:0] $end
$var wire 32 ( debug_pc [31:0] $end
$var wire 32 ) debug_instr [31:0] $end
$var reg 1 * clk $end
$var reg 1 + debug_en $end
$var reg 1 , fiq $end
$var reg 1 - halt $end
$var reg 1 . irq $end
$var reg 32 / mem_rdata [31:0] $end
$var reg 1 0 rst_n $end
$scope module u_dut $end
$var wire 32 1 block_base_address [31:0] $end
$var wire 4 2 block_base_register [3:0] $end
$var wire 1 3 block_en $end
$var wire 1 4 block_load $end
$var wire 1 5 block_pre $end
$var wire 32 6 block_reg_rdata [31:0] $end
$var wire 1 7 block_up $end
$var wire 1 8 block_user_mode $end
$var wire 1 9 block_writeback $end
$var wire 1 * clk $end
$var wire 32 : data_mem_addr [31:0] $end
$var wire 1 + debug_en $end
$var wire 32 ; debug_instr [31:0] $end
$var wire 32 < debug_pc [31:0] $end
$var wire 1 , fiq $end
$var wire 1 - halt $end
$var wire 1 . irq $end
$var wire 1 = mem_operation_active $end
$var wire 32 > mem_rdata [31:0] $end
$var wire 1 ! mem_ready $end
$var wire 1 ? mul_en $end
$var wire 1 @ mul_set_flags $end
$var wire 32 A reg_pc_out [31:0] $end
$var wire 1 0 rst_n $end
$var wire 1 B swap_byte $end
$var wire 1 C swi_exception $end
$var wire 1 D undefined_exception $end
$var wire 1 E write_lr $end
$var wire 1 F thumb_mode $end
$var wire 1 G swap_operation $end
$var wire 1 H shifter_carry_out $end
$var wire 32 I shifted_operand [31:0] $end
$var wire 32 J reg_spsr_out [31:0] $end
$var wire 32 K reg_rn_data [31:0] $end
$var wire 32 L reg_rm_data [31:0] $end
$var wire 32 M reg_cpsr_out [31:0] $end
$var wire 1 N mul_zero $end
$var wire 1 O mul_result_ready $end
$var wire 32 P mul_result_lo [31:0] $end
$var wire 32 Q mul_result_hi [31:0] $end
$var wire 1 R mul_negative $end
$var wire 1 S mul_long $end
$var wire 1 # mem_we $end
$var wire 32 T mem_wdata [31:0] $end
$var wire 1 % mem_re $end
$var wire 4 U mem_be [3:0] $end
$var wire 32 V mem_address [31:0] $end
$var wire 32 W mem_addr [31:0] $end
$var wire 32 X lr_data [31:0] $end
$var wire 1 Y halfword_operation $end
$var wire 32 Z fetch_pc [31:0] $end
$var wire 1 [ fetch_mem_re $end
$var wire 32 \ fetch_mem_addr [31:0] $end
$var wire 32 ] fetch_instruction [31:0] $end
$var wire 1 ^ fetch_instr_valid $end
$var wire 32 _ exception_vector [31:0] $end
$var wire 3 ` exception_type [2:0] $end
$var wire 1 a exception_taken $end
$var wire 32 b exception_spsr [31:0] $end
$var wire 5 c exception_mode [4:0] $end
$var wire 32 d exception_cpsr [31:0] $end
$var wire 1 e decode_valid $end
$var wire 3 f decode_thumb_rs [2:0] $end
$var wire 3 g decode_thumb_rn [2:0] $end
$var wire 3 h decode_thumb_rd [2:0] $end
$var wire 8 i decode_thumb_offset8 [7:0] $end
$var wire 11 j decode_thumb_offset11 [10:0] $end
$var wire 4 k decode_thumb_instr_type [3:0] $end
$var wire 8 l decode_thumb_imm8 [7:0] $end
$var wire 5 m decode_thumb_imm5 [4:0] $end
$var wire 2 n decode_shift_type [1:0] $end
$var wire 5 o decode_shift_amount [4:0] $end
$var wire 1 p decode_set_flags $end
$var wire 4 q decode_rn [3:0] $end
$var wire 4 r decode_rm [3:0] $end
$var wire 4 s decode_rd [3:0] $end
$var wire 1 t decode_psr_to_reg $end
$var wire 1 u decode_psr_spsr $end
$var wire 1 v decode_psr_immediate $end
$var wire 32 w decode_pc [31:0] $end
$var wire 1 x decode_mem_writeback $end
$var wire 1 y decode_mem_up $end
$var wire 1 z decode_mem_pre $end
$var wire 1 { decode_mem_load $end
$var wire 1 | decode_mem_byte $end
$var wire 1 } decode_is_memory $end
$var wire 1 ~ decode_is_branch $end
$var wire 4 !" decode_instr_type [3:0] $end
$var wire 12 "" decode_immediate [11:0] $end
$var wire 1 #" decode_imm_en $end
$var wire 4 $" decode_cp_rn [3:0] $end
$var wire 4 %" decode_cp_rd [3:0] $end
$var wire 3 &" decode_cp_opcode2 [2:0] $end
$var wire 3 '" decode_cp_opcode1 [2:0] $end
$var wire 3 (" decode_cp_op [2:0] $end
$var wire 4 )" decode_cp_num [3:0] $end
$var wire 1 *" decode_cp_load $end
$var wire 4 +" decode_condition [3:0] $end
$var wire 24 ," decode_branch_offset [23:0] $end
$var wire 1 -" decode_branch_link $end
$var wire 4 ." decode_alu_op [3:0] $end
$var wire 5 /" current_mode [4:0] $end
$var wire 1 0" condition_passed $end
$var wire 1 1" branch_exchange $end
$var wire 16 2" block_register_list [15:0] $end
$var wire 1 3" block_reg_we $end
$var wire 32 4" block_reg_wdata [31:0] $end
$var wire 4 5" block_reg_addr [3:0] $end
$var wire 1 6" block_mem_we $end
$var wire 32 7" block_mem_wdata [31:0] $end
$var wire 1 8" block_mem_re $end
$var wire 32 9" block_mem_addr [31:0] $end
$var wire 1 :" block_complete $end
$var wire 1 ;" block_base_reg_we $end
$var wire 32 <" block_base_reg_data [31:0] $end
$var wire 4 =" block_base_reg_addr [3:0] $end
$var wire 1 >" block_active $end
$var wire 1 ?" alu_zero $end
$var wire 32 @" alu_result [31:0] $end
$var wire 1 A" alu_overflow $end
$var wire 1 B" alu_negative $end
$var wire 1 C" alu_carry_out $end
$var wire 4 D" actual_rn_addr [3:0] $end
$var wire 4 E" actual_rm_addr [3:0] $end
$var wire 4 F" actual_rd_addr [3:0] $end
$var reg 1 G" alu_carry_in $end
$var reg 32 H" alu_operand_a [31:0] $end
$var reg 32 I" alu_operand_b [31:0] $end
$var reg 1 J" branch_taken $end
$var reg 32 K" branch_target [31:0] $end
$var reg 32 L" cp_data_out [31:0] $end
$var reg 1 M" cp_exception $end
$var reg 1 N" cp_present $end
$var reg 1 O" cp_ready $end
$var reg 3 P" current_state [2:0] $end
$var reg 4 Q" data_mem_be [3:0] $end
$var reg 1 R" data_mem_re $end
$var reg 32 S" data_mem_wdata [31:0] $end
$var reg 1 T" data_mem_we $end
$var reg 4 U" effective_alu_op [3:0] $end
$var reg 1 V" fetch_en $end
$var reg 1 W" flush $end
$var reg 8 X" imm_value [7:0] $end
$var reg 32 Y" load_data [31:0] $end
$var reg 1 Z" mode_change $end
$var reg 32 [" mul_acc_hi [31:0] $end
$var reg 32 \" mul_acc_lo [31:0] $end
$var reg 1 ]" mul_accumulate $end
$var reg 1 ^" mul_hi_write_pending $end
$var reg 1 _" mul_signed $end
$var reg 2 `" mul_type [1:0] $end
$var reg 3 a" next_state [2:0] $end
$var reg 32 b" reg_cpsr_in [31:0] $end
$var reg 1 c" reg_cpsr_we $end
$var reg 32 d" reg_pc_in [31:0] $end
$var reg 1 e" reg_pc_we $end
$var reg 32 f" reg_rd_data [31:0] $end
$var reg 1 g" reg_rd_we $end
$var reg 32 h" reg_spsr_in [31:0] $end
$var reg 1 i" reg_spsr_we $end
$var reg 5 j" rot_amount [4:0] $end
$var reg 4 k" rotate_imm [3:0] $end
$var reg 1 " running $end
$var reg 1 l" save_lr $end
$var reg 1 m" stall $end
$var reg 2 n" swap_next_state [1:0] $end
$var reg 32 o" swap_read_data [31:0] $end
$var reg 2 p" swap_state [1:0] $end
$var reg 5 q" target_mode [4:0] $end
$var reg 1 r" thumb_alu_carry_out $end
$var reg 1 s" thumb_alu_negative $end
$var reg 1 t" thumb_alu_overflow $end
$var reg 32 u" thumb_alu_result [31:0] $end
$var reg 1 v" thumb_alu_zero $end
$var reg 32 w" thumb_mem_address [31:0] $end
$var reg 1 x" thumb_switch $end
$scope function evaluate_condition $end
$var reg 1 y" c $end
$var reg 4 z" cond [3:0] $end
$var reg 1 {" n $end
$var reg 1 |" v $end
$var reg 1 }" z $end
$upscope $end
$scope module u_alu $end
$var wire 4 ~" alu_op [3:0] $end
$var wire 1 G" carry_in $end
$var wire 1 C" carry_out $end
$var wire 1 * clk $end
$var wire 32 !# operand_a [31:0] $end
$var wire 32 "# operand_b [31:0] $end
$var wire 1 A" overflow $end
$var wire 32 ## result [31:0] $end
$var wire 1 0 rst_n $end
$var wire 1 ?" zero $end
$var wire 1 p set_flags $end
$var wire 1 B" negative $end
$var reg 1 $# alu_carry $end
$var reg 1 %# alu_overflow $end
$var reg 32 &# alu_result [31:0] $end
$var reg 33 '# extended_result [32:0] $end
$upscope $end
$scope module u_block_dt $end
$var wire 32 (# base_address [31:0] $end
$var wire 4 )# base_reg_addr [3:0] $end
$var wire 4 *# base_register [3:0] $end
$var wire 1 3 block_en $end
$var wire 1 4 block_load $end
$var wire 1 5 block_pre $end
$var wire 1 7 block_up $end
$var wire 1 8 block_user_mode $end
$var wire 1 9 block_writeback $end
$var wire 1 * clk $end
$var wire 32 +# mem_addr [31:0] $end
$var wire 32 ,# mem_rdata [31:0] $end
$var wire 1 8" mem_re $end
$var wire 1 ! mem_ready $end
$var wire 32 -# mem_wdata [31:0] $end
$var wire 1 6" mem_we $end
$var wire 4 .# reg_addr [3:0] $end
$var wire 32 /# reg_rdata [31:0] $end
$var wire 32 0# reg_wdata [31:0] $end
$var wire 1 3" reg_we $end
$var wire 16 1# register_list [15:0] $end
$var wire 1 0 rst_n $end
$var wire 1 :" block_complete $end
$var wire 1 >" block_active $end
$var wire 1 ;" base_reg_we $end
$var reg 32 2# base_reg_data [31:0] $end
$var reg 32 3# current_addr [31:0] $end
$var reg 4 4# current_reg [3:0] $end
$var reg 1 5# first_transfer $end
$var reg 4 6# next_reg [3:0] $end
$var reg 3 7# next_state [2:0] $end
$var reg 5 8# reg_count [4:0] $end
$var reg 16 9# remaining_regs [15:0] $end
$var reg 3 :# state [2:0] $end
$var reg 5 ;# total_regs [4:0] $end
$scope begin $ivl_for_loop3 $end
$var integer 32 <# i [31:0] $end
$upscope $end
$scope begin $ivl_for_loop4 $end
$var integer 32 =# i [31:0] $end
$upscope $end
$upscope $end
$scope module u_decode $end
$var wire 1 -" branch_link $end
$var wire 24 ># branch_offset [23:0] $end
$var wire 1 * clk $end
$var wire 4 ?# condition [3:0] $end
$var wire 1 W" flush $end
$var wire 1 #" imm_en $end
$var wire 12 @# immediate [11:0] $end
$var wire 1 } is_memory $end
$var wire 1 | mem_byte $end
$var wire 1 { mem_load $end
$var wire 1 z mem_pre $end
$var wire 1 y mem_up $end
$var wire 1 x mem_writeback $end
$var wire 1 v psr_immediate $end
$var wire 1 u psr_spsr $end
$var wire 1 t psr_to_reg $end
$var wire 4 A# rd [3:0] $end
$var wire 4 B# rm [3:0] $end
$var wire 4 C# rn [3:0] $end
$var wire 1 0 rst_n $end
$var wire 1 p set_flags $end
$var wire 5 D# shift_amount [4:0] $end
$var wire 2 E# shift_type [1:0] $end
$var wire 1 m" stall $end
$var wire 1 F thumb_mode $end
$var wire 1 F# w_bit $end
$var wire 1 G# u_bit $end
$var wire 2 H# shift_type_field [1:0] $end
$var wire 5 I# shift_amt_field [4:0] $end
$var wire 1 J# s_bit $end
$var wire 4 K# rn_field [3:0] $end
$var wire 4 L# rm_field [3:0] $end
$var wire 4 M# rd_field [3:0] $end
$var wire 32 N# pc_out [31:0] $end
$var wire 32 O# pc_in [31:0] $end
$var wire 1 P# p_bit $end
$var wire 6 Q# op_code [5:0] $end
$var wire 2 R# op_class [1:0] $end
$var wire 1 S# l_bit_mem $end
$var wire 1 T# l_bit $end
$var wire 1 ~ is_branch $end
$var wire 32 U# instruction [31:0] $end
$var wire 1 ^ instr_valid $end
$var wire 12 V# imm_field [11:0] $end
$var wire 1 W# i_bit $end
$var wire 1 e decode_valid $end
$var wire 4 X# cond_field [3:0] $end
$var wire 24 Y# branch_offset_field [23:0] $end
$var wire 1 Z# b_bit $end
$var wire 4 [# alu_op [3:0] $end
$var reg 1 *" cp_load $end
$var reg 4 \# cp_num [3:0] $end
$var reg 3 ]# cp_op [2:0] $end
$var reg 3 ^# cp_opcode1 [2:0] $end
$var reg 3 _# cp_opcode2 [2:0] $end
$var reg 4 `# cp_rd [3:0] $end
$var reg 4 a# cp_rn [3:0] $end
$var reg 4 b# instr_type [3:0] $end
$var reg 32 c# pc_reg [31:0] $end
$var reg 5 d# thumb_imm5 [4:0] $end
$var reg 8 e# thumb_imm8 [7:0] $end
$var reg 4 f# thumb_instr_type [3:0] $end
$var reg 11 g# thumb_offset11 [10:0] $end
$var reg 8 h# thumb_offset8 [7:0] $end
$var reg 3 i# thumb_rd [2:0] $end
$var reg 3 j# thumb_rn [2:0] $end
$var reg 3 k# thumb_rs [2:0] $end
$var reg 1 e valid_reg $end
$upscope $end
$scope module u_exception $end
$var wire 1 * clk $end
$var wire 5 l# current_mode [4:0] $end
$var wire 32 m# current_pc [31:0] $end
$var wire 1 n# data_abort $end
$var wire 32 o# exception_spsr [31:0] $end
$var wire 1 , fiq $end
$var wire 1 . irq $end
$var wire 1 p# prefetch_abort $end
$var wire 1 0 rst_n $end
$var wire 1 C swi $end
$var wire 1 D undefined_instr $end
$var wire 1 q# irq_disabled $end
$var wire 1 r# fiq_disabled $end
$var wire 32 s# current_cpsr [31:0] $end
$var reg 32 t# exception_cpsr [31:0] $end
$var reg 5 u# exception_mode [4:0] $end
$var reg 1 a exception_taken $end
$var reg 3 v# exception_type [2:0] $end
$var reg 32 w# exception_vector [31:0] $end
$upscope $end
$scope module u_fetch $end
$var wire 1 J" branch_taken $end
$var wire 32 x# branch_target [31:0] $end
$var wire 1 * clk $end
$var wire 1 V" fetch_en $end
$var wire 1 W" flush $end
$var wire 1 ^ instr_