$date
	Thu Jul 24 15:20:35 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module arm_instr_tb $end
$var wire 32 ! mem_rdata [31:0] $end
$var wire 1 " mem_ready $end
$var wire 1 # running $end
$var wire 1 $ mem_we $end
$var wire 32 % mem_wdata [31:0] $end
$var wire 1 & mem_re $end
$var wire 4 ' mem_be [3:0] $end
$var wire 32 ( mem_addr [31:0] $end
$var wire 32 ) debug_pc [31:0] $end
$var wire 32 * debug_instr [31:0] $end
$var reg 1 + clk $end
$var reg 1 , debug_en $end
$var reg 1 - fiq $end
$var reg 1 . halt $end
$var reg 1 / irq $end
$var reg 1 0 rst_n $end
$scope function get_alu_name $end
$var reg 4 1 op [3:0] $end
$upscope $end
$scope module dut $end
$var wire 32 2 block_base_address [31:0] $end
$var wire 4 3 block_base_register [3:0] $end
$var wire 1 4 block_en $end
$var wire 1 5 block_load $end
$var wire 1 6 block_pre $end
$var wire 32 7 block_reg_rdata [31:0] $end
$var wire 1 8 block_up $end
$var wire 1 9 block_user_mode $end
$var wire 1 : block_writeback $end
$var wire 1 + clk $end
$var wire 32 ; data_mem_addr [31:0] $end
$var wire 1 , debug_en $end
$var wire 32 < debug_instr [31:0] $end
$var wire 32 = debug_pc [31:0] $end
$var wire 1 - fiq $end
$var wire 1 . halt $end
$var wire 1 / irq $end
$var wire 1 > mem_operation_active $end
$var wire 32 ? mem_rdata [31:0] $end
$var wire 1 " mem_ready $end
$var wire 1 @ mul_en $end
$var wire 1 A mul_set_flags $end
$var wire 32 B reg_pc_out [31:0] $end
$var wire 1 0 rst_n $end
$var wire 1 C swap_byte $end
$var wire 1 D swi_exception $end
$var wire 1 E undefined_exception $end
$var wire 1 F write_lr $end
$var wire 1 G thumb_mode $end
$var wire 1 H swap_operation $end
$var wire 1 I shifter_carry_out $end
$var wire 32 J shifted_operand [31:0] $end
$var wire 32 K reg_spsr_out [31:0] $end
$var wire 32 L reg_rn_data [31:0] $end
$var wire 32 M reg_rm_data [31:0] $end
$var wire 32 N reg_cpsr_out [31:0] $end
$var wire 1 O mul_zero $end
$var wire 1 P mul_result_ready $end
$var wire 32 Q mul_result_lo [31:0] $end
$var wire 32 R mul_result_hi [31:0] $end
$var wire 1 S mul_negative $end
$var wire 1 T mul_long $end
$var wire 1 $ mem_we $end
$var wire 32 U mem_wdata [31:0] $end
$var wire 1 & mem_re $end
$var wire 4 V mem_be [3:0] $end
$var wire 32 W mem_address [31:0] $end
$var wire 32 X mem_addr [31:0] $end
$var wire 32 Y lr_data [31:0] $end
$var wire 1 Z halfword_operation $end
$var wire 32 [ fetch_pc [31:0] $end
$var wire 1 \ fetch_mem_re $end
$var wire 32 ] fetch_mem_addr [31:0] $end
$var wire 32 ^ fetch_instruction [31:0] $end
$var wire 1 _ fetch_instr_valid $end
$var wire 32 ` exception_vector [31:0] $end
$var wire 3 a exception_type [2:0] $end
$var wire 1 b exception_taken $end
$var wire 32 c exception_spsr [31:0] $end
$var wire 5 d exception_mode [4:0] $end
$var wire 32 e exception_cpsr [31:0] $end
$var wire 1 f decode_valid $end
$var wire 3 g decode_thumb_rs [2:0] $end
$var wire 3 h decode_thumb_rn [2:0] $end
$var wire 3 i decode_thumb_rd [2:0] $end
$var wire 8 j decode_thumb_offset8 [7:0] $end
$var wire 11 k decode_thumb_offset11 [10:0] $end
$var wire 4 l decode_thumb_instr_type [3:0] $end
$var wire 8 m decode_thumb_imm8 [7:0] $end
$var wire 5 n decode_thumb_imm5 [4:0] $end
$var wire 2 o decode_shift_type [1:0] $end
$var wire 4 p decode_shift_rs [3:0] $end
$var wire 1 q decode_shift_reg $end
$var wire 5 r decode_shift_amount [4:0] $end
$var wire 1 s decode_set_flags $end
$var wire 4 t decode_rn [3:0] $end
$var wire 4 u decode_rm [3:0] $end
$var wire 4 v decode_rd [3:0] $end
$var wire 1 w decode_psr_to_reg $end
$var wire 1 x decode_psr_spsr $end
$var wire 1 y decode_psr_immediate $end
$var wire 32 z decode_pc [31:0] $end
$var wire 1 { decode_mem_writeback $end
$var wire 1 | decode_mem_up $end
$var wire 1 } decode_mem_pre $end
$var wire 1 ~ decode_mem_load $end
$var wire 1 !" decode_mem_byte $end
$var wire 1 "" decode_is_memory $end
$var wire 1 #" decode_is_branch $end
$var wire 4 $" decode_instr_type [3:0] $end
$var wire 12 %" decode_immediate [11:0] $end
$var wire 1 &" decode_imm_en $end
$var wire 4 '" decode_cp_rn [3:0] $end
$var wire 4 (" decode_cp_rd [3:0] $end
$var wire 3 )" decode_cp_opcode2 [2:0] $end
$var wire 3 *" decode_cp_opcode1 [2:0] $end
$var wire 3 +" decode_cp_op [2:0] $end
$var wire 4 ," decode_cp_num [3:0] $end
$var wire 1 -" decode_cp_load $end
$var wire 4 ." decode_condition [3:0] $end
$var wire 24 /" decode_branch_offset [23:0] $end
$var wire 1 0" decode_branch_link $end
$var wire 4 1" decode_alu_op [3:0] $end
$var wire 5 2" current_mode [4:0] $end
$var wire 1 3" condition_passed $end
$var wire 1 4" branch_exchange $end
$var wire 16 5" block_register_list [15:0] $end
$var wire 1 6" block_reg_we $end
$var wire 32 7" block_reg_wdata [31:0] $end
$var wire 4 8" block_reg_addr [3:0] $end
$var wire 1 9" block_mem_we $end
$var wire 32 :" block_mem_wdata [31:0] $end
$var wire 1 ;" block_mem_re $end
$var wire 32 <" block_mem_addr [31:0] $end
$var wire 1 =" block_complete $end
$var wire 1 >" block_base_reg_we $end
$var wire 32 ?" block_base_reg_data [31:0] $end
$var wire 4 @" block_base_reg_addr [3:0] $end
$var wire 1 A" block_active $end
$var wire 1 B" alu_zero $end
$var wire 32 C" alu_result [31:0] $end
$var wire 1 D" alu_overflow $end
$var wire 1 E" alu_negative $end
$var wire 1 F" alu_carry_out $end
$var wire 4 G" actual_rn_addr [3:0] $end
$var wire 4 H" actual_rm_addr [3:0] $end
$var wire 4 I" actual_rd_addr [3:0] $end
$var reg 1 J" alu_carry_in $end
$var reg 32 K" alu_operand_a [31:0] $end
$var reg 32 L" alu_operand_b [31:0] $end
$var reg 32 M" arm_mem_offset [31:0] $end
$var reg 1 N" branch_taken $end
$var reg 32 O" branch_target [31:0] $end
$var reg 32 P" cp_data_out [31:0] $end
$var reg 1 Q" cp_exception $end
$var reg 1 R" cp_present $end
$var reg 1 S" cp_ready $end
$var reg 3 T" current_state [2:0] $end
$var reg 4 U" data_mem_be [3:0] $end
$var reg 1 V" data_mem_re $end
$var reg 32 W" data_mem_wdata [31:0] $end
$var reg 1 X" data_mem_we $end
$var reg 4 Y" effective_alu_op [3:0] $end
$var reg 5 Z" effective_shift_amount [4:0] $end
$var reg 32 [" effective_shift_data [31:0] $end
$var reg 1 \" fetch_en $end
$var reg 1 ]" flush $end
$var reg 8 ^" imm_value [7:0] $end
$var reg 32 _" load_data [31:0] $end
$var reg 1 `" mode_change $end
$var reg 32 a" mul_acc_hi [31:0] $end
$var reg 32 b" mul_acc_lo [31:0] $end
$var reg 1 c" mul_accumulate $end
$var reg 1 d" mul_hi_write_pending $end
$var reg 1 e" mul_signed $end
$var reg 2 f" mul_type [1:0] $end
$var reg 3 g" next_state [2:0] $end
$var reg 32 h" reg_cpsr_in [31:0] $end
$var reg 1 i" reg_cpsr_we $end
$var reg 32 j" reg_pc_in [31:0] $end
$var reg 1 k" reg_pc_we $end
$var reg 32 l" reg_rd_data [31:0] $end
$var reg 1 m" reg_rd_we $end
$var reg 32 n" reg_spsr_in [31:0] $end
$var reg 1 o" reg_spsr_we $end
$var reg 5 p" rot_amount [4:0] $end
$var reg 4 q" rotate_imm [3:0] $end
$var reg 1 # running $end
$var reg 1 r" save_lr $end
$var reg 1 s" stall $end
$var reg 2 t" swap_next_state [1:0] $end
$var reg 32 u" swap_read_data [31:0] $end
$var reg 2 v" swap_state [1:0] $end
$var reg 5 w" target_mode [4:0] $end
$var reg 1 x" thumb_alu_carry_out $end
$var reg 1 y" thumb_alu_negative $end
$var reg 1 z" thumb_alu_overflow $end
$var reg 32 {" thumb_alu_result [31:0] $end
$var reg 1 |" thumb_alu_zero $end
$var reg 32 }" thumb_mem_address [31:0] $end
$var reg 1 ~" thumb_switch $end
$scope function evaluate_condition $end
$var reg 1 !# c $end
$var reg 4 "# cond [3:0] $end
$var reg 1 ## n $end
$var reg 1 $# v $end
$var reg 1 %# z $end
$upscope $end
$scope module u_alu $end
$var wire 4 &# alu_op [3:0] $end
$var wire 1 J" carry_in $end
$var wire 1 F" carry_out $end
$var wire 1 + clk $end
$var wire 32 '# operand_a [31:0] $end
$var wire 32 (# operand_b [31:0] $end
$var wire 1 D" overflow $end
$var wire 32 )# result [31:0] $end
$var wire 1 0 rst_n $end
$var wire 1 B" zero $end
$var wire 1 s set_flags $end
$var wire 1 E" negative $end
$var reg 1 *# alu_carry $end
$var reg 1 +# alu_overflow $end
$var reg 32 ,# alu_result [31:0] $end
$var reg 33 -# extended_result [32:0] $end
$upscope $end
$scope module u_block_dt $end
$var wire 32 .# base_address [31:0] $end
$var wire 4 /# base_reg_addr [3:0] $end
$var wire 4 0# base_register [3:0] $end
$var wire 1 4 block_en $end
$var wire 1 5 block_load $end
$var wire 1 6 block_pre $end
$var wire 1 8 block_up $end
$var wire 1 9 block_user_mode $end
$var wire 1 : block_writeback $end
$var wire 1 + clk $end
$var wire 32 1# mem_addr [31:0] $end
$var wire 32 2# mem_rdata [31:0] $end
$var wire 1 ;" mem_re $end
$var wire 1 " mem_ready $end
$var wire 32 3# mem_wdata [31:0] $end
$var wire 1 9" mem_we $end
$var wire 4 4# reg_addr [3:0] $end
$var wire 32 5# reg_rdata [31:0] $end
$var wire 32 6# reg_wdata [31:0] $end
$var wire 1 6" reg_we $end
$var wire 16 7# register_list [15:0] $end
$var wire 1 0 rst_n $end
$var wire 1 =" block_complete $end
$var wire 1 A" block_active $end
$var wire 1 >" base_reg_we $end
$var reg 32 8# base_reg_data [31:0] $end
$var reg 32 9# current_addr [31:0] $end
$var reg 4 :# current_reg [3:0] $end
$var reg 1 ;# first_transfer $end
$var reg 4 <# next_reg [3:0] $end
$var reg 3 =# next_state [2:0] $end
$var reg 5 ># reg_count [4:0] $end
$var reg 16 ?# remaining_regs [15:0] $end
$var reg 3 @# state [2:0] $end
$var reg 5 A# total_regs [4:0] $end
$scope begin $ivl_for_loop3 $end
$var integer 32 B# i [31:0] $end
$upscope $end
$scope begin $ivl_for_loop4 $end
$var integer 32 C# i [31:0] $end
$upscope $end
$upscope $end
$scope module u_decode $end
$var wire 1 0" branch_link $end
$var wire 24 D# branch_offset [23:0] $end
$var wire 1 + clk $end
$var wire 4 E# condition [3:0] $end
$var wire 1 ]" flush $end
$var wire 1 &" imm_en $end
$var wire 12 F# immediate [11:0] $end
$var wire 1 "" is_memory $end
$var wire 1 !" mem_byte $end
$var wire 1 ~ mem_load $end
$var wire 1 } mem_pre $end
$var wire 1 | mem_up $end
$var wire 1 { mem_writeback $end
$var wire 1 y psr_immediate $end
$var wire 1 x psr_spsr $end
$var wire 1 w psr_to_reg $end
$var wire 4 G# rd [3:0] $end
$var wire 4 H# rm [3:0] $end
$var wire 4 I# rn [3:0] $end
$var wire 1 0 rst_n $end
$var wire 1 s set_flags $end
$var wire 1 q shift_reg $end
$var wire 2 J# shift_type [1:0] $end
$var wire 1 s" stall $end
$var wire 1 G thumb_mode $end
$var wire 1 K# w_bit $end
$var wire 1 L# u_bit $end
$var wire 2 M# shift_type_field [1:0] $end
$var wire 4 N# shift_rs [3:0] $end
$var wire 5 O# shift_amt_field [4:0] $end
$var wire 5 P# shift_amount [4:0] $end
$var wire 1 Q# s_bit $end
$var wire 4 R# rn_field [3:0] $end
$var wire 4 S# rm_field [3:0] $end
$var wire 4 T# rd_field [3:0] $end
$var wire 32 U# pc_out [31:0] $end
$var wire 32 V# pc_in [31:0] $end
$var wire 1 W# p_bit $end
$var wire 6 X# op_code [5:0] $end
$var wire 2 Y# op_class [1:0] $end
$var wire 1 Z# l_bit_mem $end
$var wire 1 [# l_bit $end
$var wire 1 #" is_branch $end
$var wire 32 \# instruction [31:0] $end
$var wire 1 _ instr_valid $end
$var wire 12 ]# imm_field [11:0] $end
$var wire 1 ^# i_bit $end
$var wire 1 f decode_valid $end
$var wire 4 _# cond_field [3:0] $end
$var wire 24 `# branch_offset_field [23:0] $end
$var wire 1 a# b_bit $end
$var wire 4 b# alu_op [3:0] $end
$var reg 1 -" cp_load $end
$var reg 4 c# cp_num [3:0] $end
$var reg 3 d# cp_op [2:0] $end
$var reg 3 e# cp_opcode1 [2:0] $end
$var reg 3 f# cp_opcode2 [2:0] $end
$var reg 4 g# cp_rd [3:0] $end
$var reg 4 h# cp_rn [3:0] $end
$var reg 4 i# instr_type [3:0] $end
$var reg 32 j# pc_reg [31:0] $end
$var reg 5 k# thumb_imm5 [4:0] $end
$var reg 8 l# thumb_imm8 [7:0] $end
$var reg 4 m# thumb_instr_type [3:0] $end
$var reg 11 n# thumb_offset11 [10:0] $end
$var reg 8 o# thumb_offset8 [7:0] $end
$var reg 3 p# thumb_rd [2:0] $end
$var reg 3 q# thumb_rn [2:0] $end
$var reg 3 r# thumb_rs [2:0] $end
$var reg 1 f valid_reg $end
$upscope $end
$scope module u_exception $end
$var wire 1 + clk $end
$var wire 5 s# current_mode [4:0] $end
$var wire 32 t# current_pc [31:0] $end
$var wire 1 u# data_abort $end
$var wire 32 v# exception_spsr [31:0] $end
$var wire 1 - fiq $end
$var wire 1 / irq $end
$var wire 1 w# prefetch_abort $end
$var wire 1 0 rst_n $end
$var wire 1 D swi $end
$var wire 1 E undefined_instr $end
$var wire 1 x# irq_disabled $end
$var wire 1 y# fiq_disabled $end
$var wire 32 z# current_cpsr [31:0] $end
$var reg 32 {# exception_cpsr [31:0] $end
$var reg 5 |# e