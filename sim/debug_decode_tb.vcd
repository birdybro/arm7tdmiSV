$date
	Thu Jul 24 17:44:40 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module debug_decode_tb $end
$var wire 1 ! decode_valid $end
$var wire 3 " decode_thumb_rs [2:0] $end
$var wire 3 # decode_thumb_rn [2:0] $end
$var wire 3 $ decode_thumb_rd [2:0] $end
$var wire 8 % decode_thumb_offset8 [7:0] $end
$var wire 11 & decode_thumb_offset11 [10:0] $end
$var wire 5 ' decode_thumb_instr_type [4:0] $end
$var wire 8 ( decode_thumb_imm8 [7:0] $end
$var wire 5 ) decode_thumb_imm5 [4:0] $end
$var wire 2 * decode_shift_type [1:0] $end
$var wire 4 + decode_shift_rs [3:0] $end
$var wire 1 , decode_shift_reg $end
$var wire 5 - decode_shift_amount [4:0] $end
$var wire 1 . decode_set_flags $end
$var wire 4 / decode_rn [3:0] $end
$var wire 4 0 decode_rm [3:0] $end
$var wire 4 1 decode_rd [3:0] $end
$var wire 1 2 decode_psr_to_reg $end
$var wire 1 3 decode_psr_spsr $end
$var wire 1 4 decode_psr_immediate $end
$var wire 32 5 decode_pc [31:0] $end
$var wire 1 6 decode_mem_writeback $end
$var wire 1 7 decode_mem_up $end
$var wire 1 8 decode_mem_pre $end
$var wire 1 9 decode_mem_load $end
$var wire 1 : decode_mem_byte $end
$var wire 1 ; decode_is_memory $end
$var wire 1 < decode_is_branch $end
$var wire 4 = decode_instr_type [3:0] $end
$var wire 12 > decode_immediate [11:0] $end
$var wire 1 ? decode_imm_en $end
$var wire 4 @ decode_cp_rn [3:0] $end
$var wire 4 A decode_cp_rd [3:0] $end
$var wire 3 B decode_cp_opcode2 [2:0] $end
$var wire 3 C decode_cp_opcode1 [2:0] $end
$var wire 3 D decode_cp_op [2:0] $end
$var wire 4 E decode_cp_num [3:0] $end
$var wire 1 F decode_cp_load $end
$var wire 4 G decode_condition [3:0] $end
$var wire 24 H decode_branch_offset [23:0] $end
$var wire 1 I decode_branch_link $end
$var wire 4 J decode_alu_op [3:0] $end
$var reg 1 K clk $end
$var reg 1 L flush $end
$var reg 1 M instr_valid $end
$var reg 32 N instruction [31:0] $end
$var reg 32 O pc_in [31:0] $end
$var reg 1 P rst_n $end
$var reg 1 Q stall $end
$var reg 1 R thumb_mode $end
$scope module u_decode $end
$var wire 1 I branch_link $end
$var wire 24 S branch_offset [23:0] $end
$var wire 1 K clk $end
$var wire 4 T condition [3:0] $end
$var wire 1 ! decode_valid $end
$var wire 1 L flush $end
$var wire 1 ? imm_en $end
$var wire 12 U immediate [11:0] $end
$var wire 1 M instr_valid $end
$var wire 32 V instruction [31:0] $end
$var wire 1 ; is_memory $end
$var wire 1 : mem_byte $end
$var wire 1 9 mem_load $end
$var wire 1 8 mem_pre $end
$var wire 1 7 mem_up $end
$var wire 1 6 mem_writeback $end
$var wire 32 W pc_in [31:0] $end
$var wire 32 X pc_out [31:0] $end
$var wire 1 4 psr_immediate $end
$var wire 1 3 psr_spsr $end
$var wire 1 2 psr_to_reg $end
$var wire 4 Y rd [3:0] $end
$var wire 4 Z rm [3:0] $end
$var wire 4 [ rn [3:0] $end
$var wire 1 P rst_n $end
$var wire 1 . set_flags $end
$var wire 1 , shift_reg $end
$var wire 2 \ shift_type [1:0] $end
$var wire 1 Q stall $end
$var wire 1 R thumb_mode $end
$var wire 1 ] w_bit $end
$var wire 1 ^ u_bit $end
$var wire 2 _ shift_type_field [1:0] $end
$var wire 4 ` shift_rs [3:0] $end
$var wire 5 a shift_amt_field [4:0] $end
$var wire 5 b shift_amount [4:0] $end
$var wire 1 c s_bit $end
$var wire 4 d rn_field [3:0] $end
$var wire 4 e rm_field [3:0] $end
$var wire 4 f rd_field [3:0] $end
$var wire 1 g p_bit $end
$var wire 6 h op_code [5:0] $end
$var wire 2 i op_class [1:0] $end
$var wire 1 j l_bit_mem $end
$var wire 1 k l_bit $end
$var wire 1 < is_branch $end
$var wire 12 l imm_field [11:0] $end
$var wire 1 m i_bit $end
$var wire 4 n cond_field [3:0] $end
$var wire 24 o branch_offset_field [23:0] $end
$var wire 1 p b_bit $end
$var wire 4 q alu_op [3:0] $end
$var reg 1 F cp_load $end
$var reg 4 r cp_num [3:0] $end
$var reg 3 s cp_op [2:0] $end
$var reg 3 t cp_opcode1 [2:0] $end
$var reg 3 u cp_opcode2 [2:0] $end
$var reg 4 v cp_rd [3:0] $end
$var reg 4 w cp_rn [3:0] $end
$var reg 4 x instr_type [3:0] $end
$var reg 32 y pc_reg [31:0] $end
$var reg 5 z thumb_imm5 [4:0] $end
$var reg 8 { thumb_imm8 [7:0] $end
$var reg 5 | thumb_instr_type [4:0] $end
$var reg 11 } thumb_offset11 [10:0] $end
$var reg 8 ~ thumb_offset8 [7:0] $end
$var reg 3 !" thumb_rd [2:0] $end
$var reg 3 "" thumb_rn [2:0] $end
$var reg 3 #" thumb_rs [2:0] $end
$var reg 1 $" valid_reg $end
$upscope $end
$scope task test_instruction $end
$var reg 4 %" expected_type [3:0] $end
$var reg 32 &" instr [31:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx &"
bx %"
0$"
b0 #"
b0 ""
b0 !"
b0 ~
b0 }
b1 |
b0 {
b0 z
b0 y
b111 x
b0 w
b0 v
b0 u
b0 t
b0 s
b0 r
bx q
xp
bx o
bx n
xm
bx l
xk
xj
bx i
bx h
xg
bx f
bx e
bx d
xc
bx b
bx a
bx `
bx _
x^
x]
bx \
bx [
bx Z
bx Y
b0 X
b0 W
bx V
bx U
bx T
bx S
0R
0Q
0P
b0 O
bx N
1M
0L
0K
bx J
0I
bx H
bx G
0F
b0 E
b0 D
b0 C
b0 B
b0 A
b0 @
0?
bx >
b111 =
0<
0;
x:
x9
x8
x7
x6
b0 5
04
03
02
bx 1
bx 0
bx /
0.
bx -
0,
bx +
bx *
b0 )
b0 (
b1 '
b0 &
b0 %
b0 $
b0 #
b0 "
0!
$end
#5000
1K
#10000
0K
#15000
1!
1$"
1P
1K
#20000
0K
#25000
1K
#30000
0K
#35000
b11110 -
b11110 b
b100 =
b100 x
b1110 G
b1110 T
b1110 n
b0 i
0m
b100101 h
0c
b1111 /
b1111 [
b1111 d
b1111 1
b1111 Y
b1111 f
b0 0
b0 Z
b0 e
b111100010000 >
b111100010000 U
b111100010000 l
b0 *
b0 \
b0 _
b11110 a
1k
b1011111111111100010000 H
b1011111111111100010000 S
b1011111111111100010000 o
18
1g
07
0^
0:
0p
16
1]
09
0j
b1001 J
b1001 q
b1111 +
b1111 `
b11100001001011111111111100010000 N
b11100001001011111111111100010000 V
1K
#40000
0K
#45000
b100 =
b100 x
b1 0
b1 Z
b1 e
b111100010001 >
b111100010001 U
b111100010001 l
b1011111111111100010001 H
b1011111111111100010001 S
b1011111111111100010001 o
b11100001001011111111111100010001 N
b11100001001011111111111100010001 V
1K
#50000
0K
#55000
b100 =
b100 x
b1110 0
b1110 Z
b1110 e
b111100011110 >
b111100011110 U
b111100011110 l
b1011111111111100011110 H
b1011111111111100011110 S
b1011111111111100011110 o
b11100001001011111111111100011110 N
b11100001001011111111111100011110 V
1K
#60000
0K
#65000
1K
