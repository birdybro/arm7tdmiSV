$date
	Thu Jul 24 19:34:32 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module memory_interface_test_tb $end
$var wire 1 ! mem_re $end
$var wire 32 " mem_wdata [31:0] $end
$var wire 1 # mem_we $end
$var wire 32 $ mem_rdata [31:0] $end
$var wire 32 % mem_addr [31:0] $end
$var wire 1 & decode_valid $end
$var wire 1 ' decode_set_flags $end
$var wire 4 ( decode_rn [3:0] $end
$var wire 4 ) decode_rm [3:0] $end
$var wire 4 * decode_rd [3:0] $end
$var wire 32 + decode_pc [31:0] $end
$var wire 1 , decode_mem_writeback $end
$var wire 1 - decode_mem_up $end
$var wire 1 . decode_mem_pre $end
$var wire 1 / decode_mem_load $end
$var wire 1 0 decode_mem_byte $end
$var wire 1 1 decode_is_memory $end
$var wire 4 2 decode_instr_type [3:0] $end
$var wire 12 3 decode_immediate [11:0] $end
$var wire 1 4 decode_imm_en $end
$var wire 4 5 decode_condition [3:0] $end
$var wire 4 6 decode_alu_op [3:0] $end
$var reg 32 7 actual_mem [31:0] $end
$var reg 1 8 clk $end
$var reg 1 9 flush $end
$var reg 1 : instr_valid $end
$var reg 32 ; instruction [31:0] $end
$var reg 32 < mem_address [31:0] $end
$var reg 4 = mem_be [3:0] $end
$var reg 1 > mem_ready $end
$var reg 32 ? pc_in [31:0] $end
$var reg 32 @ reg_rm_data [31:0] $end
$var reg 32 A reg_rn_data [31:0] $end
$var reg 1 B rst_n $end
$var reg 1 C stall $end
$var reg 1 D test_passed $end
$var reg 1 E thumb_mode $end
$var integer 32 F tests_passed [31:0] $end
$var integer 32 G tests_run [31:0] $end
$scope module u_decode $end
$var wire 1 H branch_link $end
$var wire 24 I branch_offset [23:0] $end
$var wire 1 8 clk $end
$var wire 4 J condition [3:0] $end
$var wire 1 9 flush $end
$var wire 1 4 imm_en $end
$var wire 12 K immediate [11:0] $end
$var wire 1 : instr_valid $end
$var wire 32 L instruction [31:0] $end
$var wire 1 1 is_memory $end
$var wire 1 0 mem_byte $end
$var wire 1 / mem_load $end
$var wire 1 . mem_pre $end
$var wire 1 - mem_up $end
$var wire 1 , mem_writeback $end
$var wire 32 M pc_in [31:0] $end
$var wire 32 N pc_out [31:0] $end
$var wire 1 O psr_immediate $end
$var wire 1 P psr_spsr $end
$var wire 1 Q psr_to_reg $end
$var wire 4 R rd [3:0] $end
$var wire 4 S rm [3:0] $end
$var wire 4 T rn [3:0] $end
$var wire 1 B rst_n $end
$var wire 1 ' set_flags $end
$var wire 1 U shift_reg $end
$var wire 2 V shift_type [1:0] $end
$var wire 1 C stall $end
$var wire 1 E thumb_mode $end
$var wire 1 W w_bit $end
$var wire 1 X u_bit $end
$var wire 2 Y shift_type_field [1:0] $end
$var wire 4 Z shift_rs [3:0] $end
$var wire 5 [ shift_amt_field [4:0] $end
$var wire 5 \ shift_amount [4:0] $end
$var wire 1 ] s_bit $end
$var wire 4 ^ rn_field [3:0] $end
$var wire 4 _ rm_field [3:0] $end
$var wire 4 ` rd_field [3:0] $end
$var wire 1 a p_bit $end
$var wire 6 b op_code [5:0] $end
$var wire 2 c op_class [1:0] $end
$var wire 1 d l_bit_mem $end
$var wire 1 e l_bit $end
$var wire 1 f is_branch $end
$var wire 12 g imm_field [11:0] $end
$var wire 1 h i_bit $end
$var wire 1 & decode_valid $end
$var wire 4 i cond_field [3:0] $end
$var wire 24 j branch_offset_field [23:0] $end
$var wire 1 k b_bit $end
$var wire 4 l alu_op [3:0] $end
$var reg 1 m cp_load $end
$var reg 4 n cp_num [3:0] $end
$var reg 3 o cp_op [2:0] $end
$var reg 3 p cp_opcode1 [2:0] $end
$var reg 3 q cp_opcode2 [2:0] $end
$var reg 4 r cp_rd [3:0] $end
$var reg 4 s cp_rn [3:0] $end
$var reg 4 t instr_type [3:0] $end
$var reg 32 u pc_reg [31:0] $end
$var reg 5 v thumb_imm5 [4:0] $end
$var reg 8 w thumb_imm8 [7:0] $end
$var reg 5 x thumb_instr_type [4:0] $end
$var reg 11 y thumb_offset11 [10:0] $end
$var reg 8 z thumb_offset8 [7:0] $end
$var reg 3 { thumb_rd [2:0] $end
$var reg 3 | thumb_rn [2:0] $end
$var reg 3 } thumb_rs [2:0] $end
$var reg 1 & valid_reg $end
$upscope $end
$scope begin $ivl_for_loop1 $end
$var integer 32 ~ i [31:0] $end
$upscope $end
$scope task test_memory_instruction $end
$var reg 32 !" base_addr [31:0] $end
$var reg 32 "" expected_addr [31:0] $end
$var reg 32 #" expected_result [31:0] $end
$var reg 32 $" instr [31:0] $end
$var reg 1 %" is_load $end
$var reg 32 &" test_data [31:0] $end
$scope begin $ivl_for_loop0 $end
$var integer 32 '" i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b0 '"
bx &"
x%"
bx $"
bx #"
bx ""
bx !"
b100000000 ~
b0 }
b0 |
b0 {
b0 z
b0 y
b1 x
b0 w
b0 v
b0 u
b111 t
b0 s
b0 r
b0 q
b0 p
b0 o
b0 n
0m
bx l
xk
bx j
bx i
xh
bx g
0f
xe
xd
bx c
bx b
xa
bx `
bx _
bx ^
x]
bx \
bx [
bx Z
bx Y
xX
xW
bx V
0U
bx T
bx S
bx R
0Q
0P
0O
b0 N
b0 M
bx L
bx K
bx J
bx I
0H
b0 G
b0 F
0E
xD
0C
0B
b1000000000000 A
b10010001101000101011001111000 @
b0 ?
1>
b1111 =
b1000000000000 <
bx ;
1:
09
08
bx 7
bx 6
bx 5
04
bx 3
b111 2
01
x0
x/
x.
x-
x,
b0 +
bx *
bx )
bx (
0'
0&
b1000000000000 %
b0 $
0#
b10010001101000101011001111000 "
0!
$end
#5000
18
#10000
08
#15000
1&
1B
18
#20000
08
#25000
18
#30000
08
#35000
1#
14
11
b0 \
b110 2
b110 t
b1110 5
b1110 J
b1110 i
b1 c
0h
b110000 b
0]
b1 (
b1 T
b1 ^
b0 *
b0 R
b0 `
b0 )
b0 S
b0 _
b0 3
b0 K
b0 g
b0 V
b0 Y
b0 [
1e
b100000010000000000000000 I
b100000010000000000000000 j
1.
1a
1-
1X
00
0k
0,
0W
0/
0d
b1100 6
b1100 l
b0 Z
b100000000 '"
b11100101100000010000000000000000 ;
b11100101100000010000000000000000 L
b1 G
b1000000000000 ""
0%"
b10010001101000101011001111000 #"
b10010001101000101011001111000 &"
b1000000000000 !"
b11100101100000010000000000000000 $"
18
#40000
08
#45000
18
#50000
08
#55000
18
#60000
08
#65000
b10000111011001010100001100100001 $
0#
1!
b110010 b
1]
b100100010000000000000000 I
b100100010000000000000000 j
1/
1d
b110 2
b110 t
b1000000000100 %
b1000000000100 <
b100000000 '"
b11100101100100010000000000000000 ;
b11100101100100010000000000000000 L
b10000111011001010100001100100001 "
b10000111011001010100001100100001 @
b1000000000100 A
b10 G
b1000000000100 ""
1%"
b10000111011001010100001100100001 #"
b10000111011001010100001100100001 &"
b1000000000100 !"
b11100101100100010000000000000000 $"
b1 F
b1000000000100 7
1D
18
#70000
08
#75000
18
#80000
08
#85000
18
#90000
08
#95000
1#
0!
b0 $
b110000 b
0]
b100 )
b100 S
b100 _
b100 3
b100 K
b100 g
b100000010000000000000100 I
b100000010000000000000100 j
0/
0d
b110 2
b110 t
b1000000000100 %
b1000000000100 <
b100000000 '"
b11100101100000010000000000000100 ;
b11100101100000010000000000000100 L
b10101010101110111100110011011101 "
b10101010101110111100110011011101 @
b1000000000000 A
b11 G
0%"
b10101010101110111100110011011101 #"
b10101010101110111100110011011101 &"
b1000000000000 !"
b11100101100000010000000000000100 $"
b10 F
1D
18
#100000
08
#105000
18
#110000
08
#115000
18
#120000
08
#125000
b10001001000100011001101000100 $
0#
1!
b1000000001000 %
b1000000001000 <
b110 2
b110 t
b110010 b
1]
b1000 )
b1000 S
b1000 _
b1000 3
b1000 K
b1000 g
b100100010000000000001000 I
b100100010000000000001000 j
1/
1d
b100000000 '"
b11100101100100010000000000001000 ;
b11100101100100010000000000001000 L
b10001001000100011001101000100 "
b10001001000100011001101000100 @
b100 G
b1000000001000 ""
1%"
b10001001000100011001101000100 #"
b10001001000100011001101000100 &"
b11100101100100010000000000001000 $"
b11 F
b1000000001000 7
1D
18
#130000
08
#135000
18
#140000
08
#145000
18
#150000
08
#155000
1#
0!
b1 =
b0 $
b111000 b
0]
b0 )
b0 S
b0 _
b0 3
b0 K
b0 g
b110000010000000000000000 I
b110000010000000000000000 j
10
1k
0/
0d
b1110 6
b1110 l
b110 2
b110 t
b1000000010000 %
b1000000010000 <
b100000000 '"
b11100101110000010000000000000000 ;
b11100101110000010000000000000000 L
b10101011 "
b10101011 @
b1000000010000 A
b101 G
b1000000010000 ""
0%"
b10101011 #"
b10101011 &"
b1000000010000 !"
b11100101110000010000000000000000 $"
b100 F
1D
18
#160000
08
#165000
18
#170000
08
#175000
18
#180000
08
#185000
b11001101 $
0#
1!
b111010 b
1]
b110100010000000000000000 I
b110100010000000000000000 j
1/
1d
b110 2
b110 t
b1000000010100 %
b1000000010100 <
b100000000 '"
b11100101110100010000000000000000 ;
b11100101110100010000000000000000 L
b11001101 "
b11001101 @
b1000000010100 A
b110 G
b1000000010100 ""
1%"
b11001101 #"
b11001101 &"
b1000000010100 !"
b11100101110100010000000000000000 $"
b101 F
b1000000010100 7
1D
18
#190000
08
#195000
18
#200000
08
#205000
18
#210000
08
#215000
b110 F
1D
18
#220000
08
#225000
18
