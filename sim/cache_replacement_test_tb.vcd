$date
	Fri Jul 25 09:37:12 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module cache_replacement_test_tb $end
$var wire 32 ! rr_replacements [31:0] $end
$var wire 32 " random_replacements [31:0] $end
$var wire 1 # mem_write $end
$var wire 32 $ mem_wdata [31:0] $end
$var wire 1 % mem_req $end
$var wire 4 & mem_byte_en [3:0] $end
$var wire 32 ' mem_addr [31:0] $end
$var wire 32 ( lru_replacements [31:0] $end
$var wire 32 ) lfu_replacements [31:0] $end
$var wire 1 * cpu_ready $end
$var wire 32 + cpu_rdata [31:0] $end
$var wire 1 , cpu_hit $end
$var wire 1 - coherency_write $end
$var wire 1 . coherency_req $end
$var wire 1 / coherency_ready $end
$var wire 32 0 coherency_addr [31:0] $end
$var wire 32 1 cache_misses [31:0] $end
$var wire 32 2 cache_hits [31:0] $end
$var wire 32 3 cache_evictions [31:0] $end
$var wire 1 4 cache_busy $end
$var reg 32 5 best_hits [31:0] $end
$var reg 1 6 cache_enable $end
$var reg 1 7 cache_flush $end
$var reg 1 8 clk $end
$var reg 32 9 cpu_addr [31:0] $end
$var reg 4 : cpu_byte_en [3:0] $end
$var reg 1 ; cpu_req $end
$var reg 2 < cpu_size [1:0] $end
$var reg 32 = cpu_wdata [31:0] $end
$var reg 1 > cpu_write $end
$var reg 32 ? initial_hits [31:0] $end
$var reg 32 @ initial_misses [31:0] $end
$var reg 32 A mem_rdata [31:0] $end
$var reg 1 B mem_ready $end
$var reg 2 C replacement_select [1:0] $end
$var reg 1 D rst_n $end
$var reg 32 E total_accesses [31:0] $end
$var integer 32 F best_policy [31:0] $end
$var real 1 G lru_rr_diff $end
$var integer 32 H test_count [31:0] $end
$var integer 32 I test_passed [31:0] $end
$scope function get_policy_characteristics $end
$var integer 32 J policy_idx [31:0] $end
$upscope $end
$scope module u_dcache $end
$var wire 1 4 cache_busy $end
$var wire 1 6 cache_enable $end
$var wire 1 7 cache_flush $end
$var wire 1 8 clk $end
$var wire 32 K coherency_addr [31:0] $end
$var wire 1 / coherency_ready $end
$var wire 1 . coherency_req $end
$var wire 1 - coherency_write $end
$var wire 32 L cpu_addr [31:0] $end
$var wire 4 M cpu_byte_en [3:0] $end
$var wire 1 , cpu_hit $end
$var wire 1 * cpu_ready $end
$var wire 1 ; cpu_req $end
$var wire 2 N cpu_size [1:0] $end
$var wire 32 O cpu_wdata [31:0] $end
$var wire 1 > cpu_write $end
$var wire 32 P mem_rdata [31:0] $end
$var wire 1 B mem_ready $end
$var wire 2 Q replacement_select [1:0] $end
$var wire 1 D rst_n $end
$var wire 2 R word_offset [1:0] $end
$var wire 2 S byte_offset [1:0] $end
$var wire 26 T addr_tag [25:0] $end
$var wire 4 U addr_offset [3:0] $end
$var wire 2 V addr_index [1:0] $end
$var reg 32 W cache_evictions [31:0] $end
$var reg 1 X cache_hit_internal $end
$var reg 32 Y cache_hits [31:0] $end
$var reg 32 Z cache_misses [31:0] $end
$var reg 32 [ cpu_rdata [31:0] $end
$var reg 2 \ fill_counter [1:0] $end
$var reg 2 ] hit_way [1:0] $end
$var reg 16 ^ lfsr [15:0] $end
$var reg 32 _ lfu_replacements [31:0] $end
$var reg 32 ` lru_replacements [31:0] $end
$var reg 32 a mem_addr [31:0] $end
$var reg 4 b mem_byte_en [3:0] $end
$var reg 1 % mem_req $end
$var reg 32 c mem_wdata [31:0] $end
$var reg 1 # mem_write $end
$var reg 2 d miss_index [1:0] $end
$var reg 26 e miss_tag [25:0] $end
$var reg 2 f miss_word_offset [1:0] $end
$var reg 3 g next_state [2:0] $end
$var reg 32 h random_replacements [31:0] $end
$var reg 2 i replace_way [1:0] $end
$var reg 32 j rr_replacements [31:0] $end
$var reg 32 k selected_word [31:0] $end
$var reg 3 l state [2:0] $end
$var reg 32 m write_data_masked [31:0] $end
$var reg 2 n writeback_counter [1:0] $end
$var reg 2 o writeback_index [1:0] $end
$var reg 26 p writeback_tag [25:0] $end
$var reg 2 q writeback_way [1:0] $end
$scope function get_lfu_way $end
$var reg 2 r lfu_way [1:0] $end
$var reg 8 s min_count [7:0] $end
$var reg 2 t set_index [1:0] $end
$scope begin $ivl_for_loop2 $end
$var integer 32 u i [31:0] $end
$upscope $end
$upscope $end
$scope function get_lru_way $end
$var reg 2 v lru_way [1:0] $end
$var reg 2 w max_order [1:0] $end
$var reg 2 x set_index [1:0] $end
$scope begin $ivl_for_loop1 $end
$var integer 32 y i [31:0] $end
$upscope $end
$upscope $end
$scope function get_random_way $end
$upscope $end
$scope begin $ivl_for_loop0 $end
$var integer 32 z i [31:0] $end
$upscope $end
$scope begin $ivl_for_loop3 $end
$var integer 32 { i [31:0] $end
$scope begin $ivl_for_loop4 $end
$var integer 32 | j [31:0] $end
$upscope $end
$upscope $end
$scope begin $ivl_for_loop5 $end
$var integer 32 } i [31:0] $end
$scope begin $ivl_for_loop6 $end
$var integer 32 ~ j [31:0] $end
$upscope $end
$upscope $end
$scope task update_lru $end
$var reg 2 !" accessed_way [1:0] $end
$var reg 2 "" set_idx [1:0] $end
$scope begin $ivl_for_loop7 $end
$var integer 32 #" i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope begin $ivl_for_loop16 $end
$var integer 32 $" i [31:0] $end
$upscope $end
$scope begin $ivl_for_loop8 $end
$var integer 32 %" i [31:0] $end
$upscope $end
$scope task cache_access $end
$var reg 32 &" addr [31:0] $end
$var reg 32 '" wdata [31:0] $end
$var reg 1 (" write $end
$upscope $end
$scope task flush_cache $end
$upscope $end
$scope task test_replacement_policy $end
$var reg 2 )" policy_sel [1:0] $end
$var integer 32 *" policy_idx [31:0] $end
$scope begin $ivl_for_loop10 $end
$var integer 32 +" round [31:0] $end
$scope begin $ivl_for_loop11 $end
$var integer 32 ," i [31:0] $end
$upscope $end
$upscope $end
$scope begin $ivl_for_loop12 $end
$var integer 32 -" i [31:0] $end
$upscope $end
$scope begin $ivl_for_loop13 $end
$var integer 32 ." i [31:0] $end
$upscope $end
$scope begin $ivl_for_loop14 $end
$var integer 32 /" round [31:0] $end
$scope begin $ivl_for_loop15 $end
$var integer 32 0" i [31:0] $end
$upscope $end
$upscope $end
$scope begin $ivl_for_loop9 $end
$var integer 32 1" i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b0 1"
b0 0"
b0 /"
b0 ."
b0 -"
b0 ,"
b0 +"
b0 *"
bx )"
x("
bx '"
bx &"
b10000000000000000 %"
b0 $"
b0 #"
bx ""
bx !"
b0 ~
b0 }
b100 |
b100 {
b100 z
b0 y
b0 x
b0 w
b0 v
b0 u
bx t
b11111111 s
b0 r
bx q
bx p
bx o
b0 n
b0 m
b0 l
b0 k
b0 j
b0 i
b0 h
b0 g
bx f
bx e
bx d
b0 c
b1111 b
b0 a
b0 `
b0 _
b1010110011100001 ^
b0 ]
b0 \
b0 [
b0 Z
b0 Y
0X
b0 W
b0 V
b0 U
b0 T
b0 S
b0 R
b0 Q
b0 P
b0 O
b10 N
b1111 M
b0 L
b0 K
b0 J
b0 I
b0 H
r0 G
b0 F
bx E
0D
b0 C
1B
b0 A
bx @
bx ?
0>
b0 =
b10 <
0;
b1111 :
b0 9
08
07
16
bx 5
04
b0 3
b0 2
b0 1
b0 0
0/
0.
0-
0,
b0 +
0*
b0 )
b0 (
b0 '
b1111 &
0%
b0 $
0#
b0 "
b0 !
$end
#5000
b100 |
b100 {
18
#10000
08
#15000
b100 |
b100 {
18
#20000
08
#25000
b100 |
b100 {
18
#30000
08
#35000
b100 |
b100 {
18
#40000
08
#45000
b100 z
b101100111000011 ^
1D
18
#50000
08
#55000
b100 z
b1011001110000111 ^
18
#60000
08
#65000
b100 z
b110011100001111 ^
18
#70000
08
#75000
b100 z
b1100111000011110 ^
18
#80000
08
#85000
b100 z
b1001110000111100 ^
18
#90000
08
#95000
b11100001111001 ^
b100 z
b100 }
b100 ~
17
b0 )"
18
#100000
08
#105000
b111000011110010 ^
b100 z
07
18
#110000
08
#115000
b100 z
b1110000111100100 ^
18
#120000
08
#125000
b1100001111001000 ^
b100 z
b1 g
b1000000000000 '
b1000000000000 a
b1000000 T
1;
b1000000000000 0
b1000000000000 K
b1000000000000 9
b1000000000000 L
b0 '"
0("
b1000000000000 &"
b0 @
b0 ?
18
#130000
08
#135000
b11 g
14
b100 z
b1 l
b1000011110010001 ^
18
#140000
08
#145000
1%
b100 z
b111100100010 ^
b1 (
b1 `
b0 f
b0 d
b1000000 e
b1 1
b1 Z
b11 l
18
#150000
08
#155000
b100 z
b1000000000100 '
b1000000000100 a
1%
b1 \
b1111001000101 ^
b11001010111111100000010000000000 A
b11001010111111100000010000000000 P
18
#160000
08
#165000
b1000000001000 '
b1000000001000 a
1%
b100 z
b11001010111111100000010000000001 A
b11001010111111100000010000000001 P
b11110010001010 ^
b10 \
18
#170000
08
#175000
b100 z
b100 g
b1000000001100 '
b1000000001100 a
1%
b11 \
b111100100010101 ^
b11001010111111100000010000000010 A
b11001010111111100000010000000010 P
18
#180000
08
#185000
b1000000000000 '
b1000000000000 a
0%
1X
b100 z
b1 i
b1 y
b0 g
1/
1*
04
b11001010111111100000010000000011 A
b11001010111111100000010000000011 P
b1111001000101010 ^
b0 \
b100 l
b100 #"
b0 !"
b0 ""
18
#190000
08
#195000
0/
0*
b1110010001010101 ^
b0 l
b100 z
1X
b1 y
b0 g
0;
18
#200000
08
#205000
b1100100010101011 ^
b100 z
0X
b0 i
b0 y
b1 x
b1 g
b100000001